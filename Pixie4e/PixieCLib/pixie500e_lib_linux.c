/************************************************************************
*  File: PIXIE500E_lib.c
*
*  Library for accessing PIXIE500E devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v10.20.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*  
* Modified by KS, spring-summer 2011. Most of the constants, the FPGA, EEPROM
* programming protocol, DMA setup, are adopted from the GenDialog code
* that was provided with the GN4124 RDK board.
*
*************************************************************************/

/*
* Some WinDriver API variables were changed from 11.20 (used for Windows) and 12.21 (used for Linux),
* so just using a different file for Linux build.
*/
#include "globals.h"
#include "utilities.h"

/*************************************************************
*  Internal definitions
*************************************************************/
/* WinDriver license registration string */
#define PIXIE500E_DEFAULT_LICENSE_STRING ""
#define PIXIE500E_DEFAULT_DRIVER_NAME "windrvr1221"
#define PIXIE500E_FCL_TIME_OUT (1000000)

#define MIN_REFCLK_DIVIN_RATIO (10000000)
#define MAX_REFCLK_DIVIN_RATIO (200000000)
#define MIN_VCO (500000000)
#define MAX_VCO (1000000000)
#define MIN_LCLK (66000000)
#define MAX_LCLK (200000000)

static CHAR gsPIXIE500E_LastErr[256];

static DWORD LibInit_count = 0;
/*************************************************************
*  Static functions prototypes and inline implementation
*************************************************************/
static BOOL DeviceValidate(const PWDC_DEVICE pDev);
static void DLLCALLCONV PIXIE500E_IntHandler(PVOID pData);
static void PIXIE500E_EventHandler(WD_EVENT *pEvent, PVOID pData);
static void ErrLog(const CHAR *sFormat, ...);
static void TraceLog(const CHAR *sFormat, ...);


static inline BOOL IsValidDevice(PWDC_DEVICE pDev, const CHAR *sFunc)
{
	if (!pDev || !WDC_GetDevContext(pDev))
	{
		snprintf(gsPIXIE500E_LastErr, sizeof(gsPIXIE500E_LastErr) - 1,
			"%s: NULL device %s\n", sFunc, !pDev ? "handle" : "context");
		ErrLog(gsPIXIE500E_LastErr);
		return FALSE;
	}

	return TRUE;
}

/*************************************************************
*  Functions implementation
*************************************************************/

/* -----------------------------------------------
*    PIXIE500E and WDC library initialize/uninit
*   ----------------------------------------------- */
DWORD PIXIE500E_LibInit(void)
{
	DWORD dwStatus;

	/* init only once */
	//if (++LibInit_count > 1)
	// KS DEBUG
	if (LibInit_count > 0)
		return WD_STATUS_SUCCESS;

#if defined(WD_DRIVER_NAME_CHANGE)
	/* Set the driver name */
	if (!WD_DriverName(PIXIE500E_DEFAULT_DRIVER_NAME))
	{
		ErrLog("Failed to set the driver name for WDC library.\n");
		return WD_SYSTEM_INTERNAL_ERROR;
	}
#endif

	/* Set WDC library's debug options (default: level TRACE, output to Debug Monitor) */
	dwStatus = WDC_SetDebugOptions(WDC_DBG_DEFAULT, NULL);
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed to initialize debug options for WDC library.\n"
			"Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));

		return dwStatus;
	}

	/* Open a handle to the driver and initialize the WDC library */
	dwStatus = WDC_DriverOpen(WDC_DRV_OPEN_DEFAULT, PIXIE500E_DEFAULT_LICENSE_STRING);
	LibInit_count++;
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed to initialize the WDC library. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));

		return dwStatus;
	}

	return WD_STATUS_SUCCESS;
}

DWORD PIXIE500E_LibUninit(void)
{
	DWORD dwStatus;
	//TODO check LibInit_count >=0 
	//if (--LibInit_count > 0)
	// KS DEBUG
	if (LibInit_count == 0)
		return WD_STATUS_SUCCESS;

	/* Uninit the WDC library and close the handle to WinDriver */
	dwStatus = WDC_DriverClose();
	// KS DEBUG
	LibInit_count--;
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed to uninit the WDC library. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));
	}

	return dwStatus;
}

/* -----------------------------------------------
*    Device open/close
*   ----------------------------------------------- */
WDC_DEVICE_HANDLE PIXIE500E_DeviceOpen(const WD_PCI_CARD_INFO *pDeviceInfo)
{
	DWORD dwStatus;
	PPIXIE500E_DEV_CTX pDevCtx = NULL;
	WDC_DEVICE_HANDLE hDev = NULL;

	/* Validate arguments */
	if (!pDeviceInfo)
	{
		ErrLog("PIXIE500E_DeviceOpen: Error - NULL device information struct pointer\n");
		return NULL;
	}

	/* Allocate memory for the PIXIE500E device context */
	pDevCtx = (PPIXIE500E_DEV_CTX)malloc(sizeof (PIXIE500E_DEV_CTX));
	if (!pDevCtx)
	{
		ErrLog("Failed allocating memory for PIXIE500E device context\n");
		return NULL;
	}

	BZERO(*pDevCtx);

	/* Open a WDC device handle */
	dwStatus = WDC_PciDeviceOpen(&hDev, pDeviceInfo, pDevCtx);
// KS DEBUG
//	dwStatus = WDC_PciDeviceOpen(&hDev, pDeviceInfo, pDevCtx, NULL, NULL, NULL);

	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed opening a WDC device handle. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));
		goto Error;
	}

	/* Validate device information */
	if (!DeviceValidate((PWDC_DEVICE)hDev))
		goto Error;

	/* Return handle to the new device */
	TraceLog("PIXIE500E_DeviceOpen: Opened a PIXIE500E device (handle 0x%p)\n", hDev);
	return hDev;

Error:    
	if (hDev)
		PIXIE500E_DeviceClose(hDev);
	else
		free(pDevCtx);

	return NULL;
}

BOOL PIXIE500E_DeviceClose(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus;
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	PPIXIE500E_DEV_CTX pDevCtx;

	TraceLog("PIXIE500E_DeviceClose entered. Device handle: 0x%p\n", hDev);

	if (!hDev)
	{
		ErrLog("PIXIE500E_DeviceClose: Error - NULL device handle\n");
		return FALSE;
	}

	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	/* Disable interrupts */
	if (WDC_IntIsEnabled(hDev))
	{
		dwStatus = PIXIE500E_IntDisable(hDev);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
				dwStatus, Stat2Str(dwStatus));
		}
	}

	/* Close the device */
	dwStatus = WDC_PciDeviceClose(hDev);
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed closing a WDC device handle (0x%p). Error 0x%lx - %s\n",
			hDev, dwStatus, Stat2Str(dwStatus));
	}

	/* Free PIXIE500E device context memory */
	if (pDevCtx)
		free (pDevCtx);

	return (WD_STATUS_SUCCESS == dwStatus);
}

static BOOL DeviceValidate(const PWDC_DEVICE pDev)
{
	DWORD i, dwNumAddrSpaces = pDev->dwNumAddrSpaces;

	/* TODO: You can modify the implementation of this function in order to
	*             verify that the device has all expected resources. */

	/* Verify that the device has at least one active address space */
	for (i = 0; i < dwNumAddrSpaces; i++)
	{
		if (WDC_AddrSpaceIsActive(pDev, i))
			return TRUE;
	}

	/* In this sample we accept the device even if it doesn't have any
	* address spaces */
	TraceLog("Device does not have any active memory or I/O address spaces\n");
	return TRUE;
}

/* -----------------------------------------------
*    Interrupts
*   ----------------------------------------------- */
static void DLLCALLCONV PIXIE500E_IntHandler(PVOID pData)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
	PPIXIE500E_DEV_CTX pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);
	PIXIE500E_INT_RESULT intResult;

	BZERO(intResult);
	intResult.dwCounter = pDev->Int.dwCounter;
	intResult.dwLost = pDev->Int.dwLost;
	intResult.waitResult = (WD_INTERRUPT_WAIT_RESULT)pDev->Int.fStopped;
	intResult.dwEnabledIntType = WDC_GET_ENABLED_INT_TYPE(pDev);
	intResult.dwLastMessage = WDC_GET_ENABLED_INT_LAST_MSG(pDev);
	//if (intResult.dwCounter % 100 == 0) ErrLog("\tPIXIE500e_IntHandler, interrupt %d!!!", pDev->Int.dwCounter );

	/* Execute the diagnostics application's interrupt handler routine */
	pDevCtx->funcDiagIntHandler((WDC_DEVICE_HANDLE)pDev, &intResult);
}

static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item)
{
	int i;
	DWORD dwNumItems = pDev->cardReg.Card.dwItems;

	for (i=0; i < (int)dwNumItems; i++)
	{
		if (pDev->cardReg.Card.Item[i].item == item)
			return TRUE;
	}

	return FALSE;
}

DWORD PIXIE500E_IntEnable(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_HANDLER funcIntHandler)
{
	DWORD dwStatus, intMask, tmp;
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	PPIXIE500E_DEV_CTX pDevCtx;
	WDC_ADDR_DESC *pAddrDesc;
	const UINT32 MAX_NUM_TRANS_CMDS = 7;
	UINT32  numOfTransCmd = 0;
	//WD_TRANSFER *pTrans;

	TraceLog("PIXIE500E_IntEnable entered. Device handle: 0x%p\n", hDev);
	// KS DEBUG
	//ErrLog("PIXIE500E_IntEnable entered. Device handle: 0x%p\n", hDev);

	if (!IsValidDevice(pDev, "PIXIE500E_IntEnable"))
		return WD_INVALID_PARAMETER;

	if (!IsItemExists(pDev, ITEM_INTERRUPT))
		return WD_OPERATION_FAILED;

	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	/* Check if interrupts are already enabled */
	if (WDC_IntIsEnabled(hDev))
	{
		ErrLog("Interrupts are already enabled ...\n");
		return WD_OPERATION_ALREADY_DONE;
	}


	/* Allocate memory for the interrupt transfer commands */
	pDevCtx->pIntTransCmds = (WD_TRANSFER*)calloc(MAX_NUM_TRANS_CMDS, sizeof(WD_TRANSFER));

	if (!pDevCtx->pIntTransCmds)
	{
		ErrLog("Failed allocating memory for interrupt transfer commands\n");
		return WD_INSUFFICIENT_RESOURCES;
	}

	/* Prepare the interrupt transfer commands */
	/* The transfer commands will be executed by WinDriver in the kernel
	*      for each interrupt that is received */

	// Read out INT_CFG0 into intMask
	dwStatus = WDC_ReadAddr32(hDev, AD_PCI_BAR4, 0x820, &intMask);

	//ErrLog("PIXIE500E_IntEnable: intMask=0x%08X\n", intMask);
	// KS DEBUG:
	// This works for SWI, when setting the correct mask in pTrans[1].Data.Dword (0x4 for SWI0, 0x8 for SWI1)
	// If GPIO interrupt is enabled (0x8000 in INT_STAT @0x814), would need to mask GPIO interrupt via writing to GPIO_INT_MASK_SET.
	// If External interrupt is enabled (0xF0) in INT_STAT @ 0x814), would need to mask external interrupt source (VDMA_EVENT) via
	// writing to VMDA_EVENT_ENABLE.

	// #1: Read from the INT_STAT register
	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
	pDevCtx->pIntTransCmds[numOfTransCmd].pPort = pAddrDesc->pAddr + 0x814;
	pDevCtx->pIntTransCmds[numOfTransCmd].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? RM_DWORD : RP_DWORD;
	numOfTransCmd++;

	// #2: Mask interrupt status from the INT_STAT register
	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
	pDevCtx->pIntTransCmds[numOfTransCmd].pPort = pAddrDesc->pAddr + 0x814;
	pDevCtx->pIntTransCmds[numOfTransCmd].cmdTrans = CMD_MASK;
	pDevCtx->pIntTransCmds[numOfTransCmd].Data.Dword = intMask;
	numOfTransCmd++;

	// #3 External interrupt(s) enabled
	if((intMask & 0xF0) != 0) { // if External Interrupt enabled
		/* The following operations are Lambo firmware specific.  Here we mask out the
		   external interrupt source (VDMA_EVENT) by writing to VDMA_EVENT_ENABLE register.
		*/
		pAddrDesc = &(pDev->pAddrDesc[AD_PCI_BAR0]); // note BAR0
		pDevCtx->pIntTransCmds[numOfTransCmd].pPort = pAddrDesc->pAddr + 0x14; // 0x14 is VDMA_EVENT_ENx
		pDevCtx->pIntTransCmds[numOfTransCmd].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? WM_DWORD : WP_DWORD;
		pDevCtx->pIntTransCmds[numOfTransCmd].Data.Dword = 0; // disable VDMA events
		numOfTransCmd++;
	}

	// #4: Write to the INT_STAT register to clear interrupts (set bit to clear ALI, INT, clear bit to clear SWI, others are RO)
	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
	pDevCtx->pIntTransCmds[numOfTransCmd].pPort = pAddrDesc->pAddr + 0x814;
	pDevCtx->pIntTransCmds[numOfTransCmd].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? WM_DWORD : WP_DWORD;
	pDevCtx->pIntTransCmds[numOfTransCmd].Data.Dword = 0xFFFFFFF3; //0x7ff3;
	numOfTransCmd++;

	// #5: Read from the INT_STAT register (ensure write completion to prevent double interrupts)
	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
	pDevCtx->pIntTransCmds[numOfTransCmd].pPort = pAddrDesc->pAddr + 0x814;
	pDevCtx->pIntTransCmds[numOfTransCmd].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? RM_DWORD : RP_DWORD;
	numOfTransCmd++;

//// BEGIN GPIO interrupt setup
//
//	// #1: Read from the INT_STAT register
//	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
//	pTrans[0].dwPort = pAddrDesc->kptAddr + 0x814;
//	pTrans[0].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? RM_DWORD : RP_DWORD;
//
//	// #2: Mask interrupt status from the INT_STAT register
//	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
//	pTrans[1].dwPort = pAddrDesc->kptAddr + 0x814;
//	pTrans[1].cmdTrans = CMD_MASK;
//	pTrans[1].Data.Dword = intMask; // mask for GPIO interrupt
//
//	// #3: Mask GPIO interrupt through GPIO_INT_MASK_SET
//	// ??? Disable the GPIO interrupts here???
//	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
//	pTrans[2].dwPort = pAddrDesc->kptAddr + 0xA1C;
//	pTrans[2].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? WM_DWORD : WP_DWORD;
//	pTrans[2].Data.Dword = 0xFFFF;
//
//
//	// #4 Write to the INT_STAT register to clear
//	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
//	pTrans[3].dwPort = pAddrDesc->kptAddr + 0x814;
//	pTrans[3].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? WM_DWORD : WP_DWORD;
//	pTrans[3].Data.Dword = 0xFFFFFFF3; 
//
//	//#5 Read from INT_STAT.  This is to ensure the write is completed before  exiting the IRQ to prevent double interrupt to occur
//	pAddrDesc = &pDev->pAddrDesc[AD_PCI_BAR4];
//	pTrans[4].dwPort = pAddrDesc->kptAddr + 0x814;
//	pTrans[4].cmdTrans = WDC_ADDR_IS_MEM(pAddrDesc) ? RM_DWORD : RP_DWORD;
//
//// END of GPIO interrupt setup


	/* Store the diag interrupt handler routine, which will be executed by
	*       PIXIE500E_IntHandler() when an interrupt is received */
	pDevCtx->funcDiagIntHandler = funcIntHandler;

	/* Enable the interrupts */
	dwStatus = WDC_IntEnable(hDev, pDevCtx->pIntTransCmds, numOfTransCmd, INTERRUPT_CMD_COPY,
		PIXIE500E_IntHandler, /*(PVOID)pDev*/hDev, WDC_IS_KP(hDev));

	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed enabling interrupts. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));

		//free(pTrans);

		return dwStatus;
	}

	/* Store the interrupt transfer commands in the device context */
	//pDevCtx->pIntTransCmds = pTrans;

	/* TODO: You can add code here to write to the device in order
	*             to physically enable the hardware interrupts */

	TraceLog("PIXIE500E_IntEnable: Interrupts enabled\n"); 
	//ErrLog("PIXIE500E_IntEnable: Interrupts enabled\n");

	return WD_STATUS_SUCCESS;
}

DWORD PIXIE500E_IntDisable(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus;
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	PPIXIE500E_DEV_CTX pDevCtx;

	TraceLog("PIXIE500E_IntDisable entered. Device handle: 0x%p\n", hDev);

	if (!IsValidDevice(pDev, "PIXIE500E_IntDisable"))
		return WD_INVALID_PARAMETER;

	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	if (!WDC_IntIsEnabled(hDev))
	{
		ErrLog("Interrupts are already disabled ...\n");
		return WD_OPERATION_ALREADY_DONE;
	}

	/* TODO: You can add code here to write to the device in order
	*             to physically disable the hardware interrupts */

	/* Disable the interrupts */
	dwStatus = WDC_IntDisable(hDev);
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));
	}

	/* Free the memory allocated for the interrupt transfer commands */
	if (pDevCtx->pIntTransCmds)
	{
		free(pDevCtx->pIntTransCmds);
		pDevCtx->pIntTransCmds = NULL;
	}

	return dwStatus;
}

BOOL PIXIE500E_IntIsEnabled(WDC_DEVICE_HANDLE hDev)
{
	if (!IsValidDevice((PWDC_DEVICE)hDev, "PIXIE500E_IntIsEnabled"))
		return FALSE;

	return WDC_IntIsEnabled(hDev);
}

/* -----------------------------------------------
*    Plug-and-play and power management events
*   ----------------------------------------------- */
static void PIXIE500E_EventHandler(WD_EVENT *pEvent, PVOID pData)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
	PPIXIE500E_DEV_CTX pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	TraceLog("PIXIE500E_EventHandler entered, pData: 0x%p, dwAction 0x%lx\n",
		pData, pEvent->dwAction);

	/* Execute the diagnostics application's event handler function */
	pDevCtx->funcDiagEventHandler((WDC_DEVICE_HANDLE)pDev, pEvent->dwAction);
}

DWORD PIXIE500E_EventRegister(WDC_DEVICE_HANDLE hDev, PIXIE500E_EVENT_HANDLER funcEventHandler)
{
	DWORD dwStatus;
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	PPIXIE500E_DEV_CTX pDevCtx;
	DWORD dwActions = WD_ACTIONS_ALL;
	/* TODO: Modify the above to set up the plug-and-play/power management
	*             events for which you wish to receive notifications.
	*             dwActions can be set to any combination of the WD_EVENT_ACTION
	*             flags defined in windrvr.h */

	TraceLog("PIXIE500E_EventRegister entered. Device handle: 0x%p\n", hDev);

	if (!IsValidDevice(pDev, "PIXIE500E_EventRegister"))
		return WD_INVALID_PARAMETER;

	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	/* Check if event is already registered */
	if (WDC_EventIsRegistered(hDev))
	{
		ErrLog("Events are already registered ...\n");
		return WD_OPERATION_ALREADY_DONE;
	}

	/* Store the diag event handler routine to be executed from PIXIE500E_EventHandler() upon an event */
	pDevCtx->funcDiagEventHandler = funcEventHandler;

	/* Register event */
	dwStatus = WDC_EventRegister(hDev, dwActions, PIXIE500E_EventHandler, hDev, FALSE);

	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed to register events. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));
		return dwStatus;
	}

	TraceLog("Events registered\n");

	return WD_STATUS_SUCCESS;
}

DWORD PIXIE500E_EventUnregister(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus;

	TraceLog("PIXIE500E_EventUnregister entered. Device handle: 0x%p\n", hDev);

	if (!IsValidDevice((PWDC_DEVICE)hDev, "PIXIE500E_EventUnregister"))
		return WD_INVALID_PARAMETER;

	if (!WDC_EventIsRegistered(hDev))
	{
		ErrLog("Cannot unregister events - no events currently registered ...\n");
		return WD_OPERATION_ALREADY_DONE;
	}

	dwStatus = WDC_EventUnregister(hDev);

	if (WD_STATUS_SUCCESS != dwStatus)
	{
		ErrLog("Failed to unregister events. Error 0x%lx - %s\n",
			dwStatus, Stat2Str(dwStatus));
	}

	return dwStatus;
}

BOOL PIXIE500E_EventIsRegistered(WDC_DEVICE_HANDLE hDev)
{
	if (!IsValidDevice((PWDC_DEVICE)hDev, "PIXIE500E_EventIsRegistered"))
		return FALSE;

	return WDC_EventIsRegistered(hDev);
}

/* -----------------------------------------------
*    Address spaces information
*   ----------------------------------------------- */
DWORD PIXIE500E_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;

	if (!IsValidDevice(pDev, "PIXIE500E_GetNumAddrSpaces"))
		return 0;

	return pDev->dwNumAddrSpaces;
}

BOOL PIXIE500E_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, PIXIE500E_ADDR_SPACE_INFO *pAddrSpaceInfo)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	WDC_ADDR_DESC *pAddrDesc;
	DWORD dwAddrSpace, dwMaxAddrSpace;
	BOOL fIsMemory;

	if (!IsValidDevice(pDev, "PIXIE500E_GetAddrSpaceInfo"))
		return FALSE;

#if defined(DEBUG)
	if (!pAddrSpaceInfo)
	{
		ErrLog("PIXIE500E_GetAddrSpaceInfo: Error - NULL address space information pointer\n");
		return FALSE;
	}
#endif

	dwAddrSpace = pAddrSpaceInfo->dwAddrSpace;
	dwMaxAddrSpace = pDev->dwNumAddrSpaces - 1;

	if (dwAddrSpace > dwMaxAddrSpace)
	{
		ErrLog("PIXIE500E_GetAddrSpaceInfo: Error - Address space %ld is out of range (0 - %ld)\n",
			dwAddrSpace, dwMaxAddrSpace);
		return FALSE;
	}

	pAddrDesc = &pDev->pAddrDesc[dwAddrSpace];

	fIsMemory = WDC_ADDR_IS_MEM(pAddrDesc);

	snprintf(pAddrSpaceInfo->sName, MAX_NAME - 1, "BAR %ld", dwAddrSpace);
	snprintf(pAddrSpaceInfo->sType, MAX_TYPE - 1, fIsMemory ? "Memory" : "I/O");

	if (WDC_AddrSpaceIsActive(pDev, dwAddrSpace))
	{
		WD_ITEMS *pItem = &pDev->cardReg.Card.Item[pAddrDesc->dwItemIndex];
		DWORD dwAddr = fIsMemory ? pItem->I.Mem.pPhysicalAddr : (DWORD)pItem->I.IO.pAddr;

/*
		snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "0x%0*lX - 0x%0*lX (0x%lx bytes)",
			(int)WDC_SIZE_32 * 2, dwAddr,
			(int)WDC_SIZE_32 * 2, dwAddr + pAddrDesc->dwBytes - 1,
			pAddrDesc->dwBytes);
*/
	}
	else
		snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "Inactive address space");

	/* TODO: You can modify the code above to set a different address space name/description */

	return TRUE;
}

// The PIXIE500E_* functions below were not generated by the Jungo's Driver Wizard.
//
// A general function for register IO
// Modified WDC_DIAG_ReadWriteReg() from wdc_diag_lib.c of WinDriver distribution.
// 
DWORD PIXIE500E_ReadWriteReg(WDC_DEVICE_HANDLE hDev, DWORD dwReg, WDC_DIRECTION direction, void *value, BOOL fPciCfg)
{
	DWORD dwStatus;
	//DWORD dwReg;
	const WDC_REG *pReg; 
	BYTE bData = 0;
	WORD wData = 0;
	UINT32 u32Data = 0;
	UINT64 u64Data = 0;

	dwStatus = WD_WINDRIVER_STATUS_ERROR;

	if (!hDev)
	{
		ErrLog("*ERROR* (PIXIE500E_ReadWriteReg): NULL WDC device handle\n");
		return dwStatus;
	}

	pReg = &gPIXIE500E_Regs[dwReg];


	if ( ((WDC_READ == direction) && (WDC_WRITE == pReg->direction)) ||
		((WDC_WRITE == direction) && (WDC_READ == pReg->direction)))
	{
		ErrLog("Error - you have selected to %s a %s-only register\n",
			(WDC_READ == direction) ? "read from" : "write to",
			(WDC_WRITE == pReg->direction) ? "write" : "read");
		return dwStatus;
	}

	switch (pReg->dwSize)
	{
	case WDC_SIZE_8:
		if (WDC_READ == direction) {
			dwStatus = fPciCfg ? WDC_PciReadCfg8(hDev, pReg->dwOffset, &bData) :
				WDC_ReadAddr8(hDev, pReg->dwAddrSpace, pReg->dwOffset, &bData);
		memcpy((BYTE*)value, &bData, WDC_SIZE_8);
		}
		else {
			memcpy(&bData, (BYTE*)value, WDC_SIZE_8);
			dwStatus = fPciCfg ? WDC_PciWriteCfg8(hDev, pReg->dwOffset, bData) :
				WDC_WriteAddr8(hDev, pReg->dwAddrSpace, pReg->dwOffset, bData);
		}
#ifdef DEBUG_PRINT
		if (WD_STATUS_SUCCESS == dwStatus)
		{
			printf("%s 0x%X %s register %s\n", (WDC_READ == direction) ? "Read" : "Wrote",
				(UINT32)bData, (WDC_READ == direction) ? "from" : "to", 
				pReg->sName);
		}
#endif
		break;
	case WDC_SIZE_16:
		if (WDC_READ == direction) {
			dwStatus = fPciCfg ? WDC_PciReadCfg16(hDev, pReg->dwOffset, &wData) :
				WDC_ReadAddr16(hDev, pReg->dwAddrSpace, pReg->dwOffset, &wData);
		memcpy((WORD*)value, &wData, WDC_SIZE_16);
		}
		else {
			memcpy(&wData, (WORD*)value, WDC_SIZE_16);
			dwStatus = fPciCfg ? WDC_PciWriteCfg16(hDev, pReg->dwOffset, wData) :
				WDC_WriteAddr16(hDev, pReg->dwAddrSpace, pReg->dwOffset, wData);
		}
#ifdef DEBUG_PRINT
		if (WD_STATUS_SUCCESS == dwStatus)
		{
			printf("%s 0x%hX %s register %s\n", (WDC_READ == direction) ? "Read" : "Wrote",
				wData, (WDC_READ == direction) ? "from" : "to", pReg->sName);
		}
#endif
		break;
	case WDC_SIZE_32:
		if (WDC_READ == direction) {
			dwStatus = fPciCfg ? WDC_PciReadCfg32(hDev, pReg->dwOffset, &u32Data) :
				WDC_ReadAddr32(hDev, pReg->dwAddrSpace, pReg->dwOffset, &u32Data);
		memcpy((UINT32*)value, &u32Data, WDC_SIZE_32);
		}
		else {
			memcpy(&u32Data, (UINT32*)value, WDC_SIZE_32);
			dwStatus = fPciCfg ? WDC_PciWriteCfg32(hDev, pReg->dwOffset, u32Data) :
				WDC_WriteAddr32(hDev, pReg->dwAddrSpace, pReg->dwOffset, u32Data);
		}
#ifdef DEBUG_PRINT
		if (WD_STATUS_SUCCESS == dwStatus)
		{
			printf("%s 0x%X %s register %s\n", (WDC_READ == direction) ? "Read" : "Wrote",
				u32Data, (WDC_READ == direction) ? "from" : "to", pReg->sName);
		}
#endif
		break;
	case WDC_SIZE_64:
		if (WDC_READ == direction) {
			dwStatus = fPciCfg ? WDC_PciReadCfg64(hDev, pReg->dwOffset, &u64Data) :
				WDC_ReadAddr64(hDev, pReg->dwAddrSpace, pReg->dwOffset, &u64Data);
		memcpy((UINT64*)value, &u64Data, WDC_SIZE_64);
		}
		else {
			memcpy(&u64Data, (UINT64*)value, WDC_SIZE_64);
			dwStatus = fPciCfg ? WDC_PciWriteCfg64(hDev, pReg->dwOffset, u64Data) :
				WDC_WriteAddr64(hDev, pReg->dwAddrSpace, pReg->dwOffset, u64Data);
		}
#ifdef DEBUG_PRINT
		if (WD_STATUS_SUCCESS == dwStatus)
		{
			printf("%s 0x%"PRI64"X %s register %s\n", (WDC_READ == direction) ? "Read" : "Wrote",
				u64Data, (WDC_READ == direction) ? "from" : "to", pReg->sName);
		}
#endif
		break;
	default:
#ifdef DEBUG_PRINT
		printf("Invalid register size (%ld)\n", pReg->dwSize);
#endif
		return dwStatus;
	}

#ifdef DEBUG_PRINT
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		printf("Failed %s %s. Error 0x%lx - %s\n",
			(WDC_READ == direction) ? "reading data from" : "writing data to",
			pReg->sName, dwStatus, Stat2Str(dwStatus));
	}
#endif

	return dwStatus;
}

/* -----------------------------------------------
*    Debugging and error handling
*   ----------------------------------------------- */
static void ErrLog(const CHAR *sFormat, ...)
{
	va_list argp;
	va_start(argp, sFormat);
	vsnprintf(gsPIXIE500E_LastErr, sizeof(gsPIXIE500E_LastErr) - 1, sFormat, argp);
	// KS use Pixie_Print_MSG() for error output
	Pixie_Print_MSG(PIXIE500E_GetLastErr(),1);
#if defined(DEBUG)
	WDC_Err("PIXIE500E lib: %s", PIXIE500E_GetLastErr());
#endif
	va_end(argp);
}

static void TraceLog(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
	CHAR sMsg[256];
	va_list argp;
	va_start(argp, sFormat);
	vsnprintf(sMsg, sizeof(sMsg) - 1, sFormat, argp);
	WDC_Trace("PIXIE500E lib: %s", sMsg);
	va_end(argp);
#endif
}

const char *PIXIE500E_GetLastErr(void)
{
	return gsPIXIE500E_LastErr;
}

/* -----------------------------------------------
*    EEPROM Read and Write
*   ----------------------------------------------- */
UINT32 PIXIE500E_ReadI2C(WDC_DEVICE_HANDLE hDev, void *buffer, UINT32 devAddr, UINT32 offset, UINT32 len)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT8 m_div_a, m_div_b; //Internal Divisor_A and Divisior_B settings


	// From GN RDK, i2c_gn4124.cpp Read()
	UINT32 tmp, i, j;
	UINT32 ctl;
	UINT32 totalTransfer=0;
	UINT8 * ptrBuff = (UINT8*)(buffer);

	BOOL errFlag = FALSE;

	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;

	// Set default baud rate
	// (div_a+1) * (div_b+1) = Fpciclk / (22 * Fscl)
	m_div_a = 1;
	m_div_b = (PCICLK / (22 * I2C_BAUD_RATE * (m_div_a + 1))) - 1;
	m_div_b &= 0x3F;

	if(hDev && IsItemExists(pDev, ITEM_MEMORY) && len > 0)
	{
		/* Shut off EEPROM_INIT state machine if not done so */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, LB_CTL, WDC_READ, &i, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (i==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash
		if((i & 0x10000) == 0)
		{
			i |= 0x10000;
			dwStatus = PIXIE500E_ReadWriteReg(hDev, LB_CTL, WDC_WRITE, &i, FALSE);
		}

		/* Initialize clock */
		/* CLR_FIFO = 1, SLVMON = 0, HOLD = 0, ACKEN = 1, NEA = 1, MS = 1, RW = 0 */
		ctl = (m_div_a << 14) | (m_div_b << 8) | 0x4E;
#if (DEBUG_PRINT)
		printf("WR TWI_CTL = 0x%x\n", ctl);
#endif
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_CTRL, WDC_WRITE, &ctl, FALSE);
		/* Read back from register to guarantee the mode change */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_CTRL, WDC_READ, &ctl, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (ctl==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

		i = MAX_RETRY;
		do
		{
			//Wait until i2c bus is idle
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_STATUS, WDC_READ, &tmp, FALSE);
			if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

			i--;
		}while((tmp & 0x100) && (i > 0));

		/* Read to clear TWI_IRT_STATUS */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_IRT_STATUS, WDC_READ, &tmp, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

		/* Write word offset */
		offset &= 0xFF;
#if (DEBUG_PRINT)
		printf("WR TWI_DATA = 0x%x\n", offset);
#endif
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_DATA, WDC_WRITE, &offset, FALSE);

		/* Write device address */
		devAddr &= 0x7F;
#if (DEBUG_PRINT)
		printf("WR TWI_ADDRESS = 0x%x\n", devAddr);
#endif
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_ADDRESS, WDC_WRITE, &devAddr, FALSE);

		j = MAX_RETRY;
		while(j > 0)
		{
			//Wait for transfer complete status
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_IRT_STATUS, WDC_READ, &tmp, FALSE);
			if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

			if(tmp & 0x1)
			{
				break;
			}
			//Time our or NACK has occurred!
			else if(tmp & 0xC)
			{
#if (DEBUG_PRINT)
				printf("NACK detected or TIMEOUT, IRT_STATUS = 0x%x!!\n", tmp);
#endif
				return 0;
			}
			j--;
		}
		//Error condition.
		if(j == 0)
		{
#if (DEBUG_PRINT)
			printf("!!!!!!!!! ERROR!!\n");
#endif
			return 0;
		}

		/* Change to read mode */
		ctl |= 0x1; //RW = 1
#if (DEBUG_PRINT)
		printf("WR TWI_CTL = 0x%x\n", ctl);
#endif
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_CTRL, WDC_WRITE, &ctl, FALSE);

		/* Perform sequential page read from the start address */
		while(len > 0 && !errFlag)
		{
			/* Write transfer length */
			if(len > I2C_FIFO_SIZE)
			{
				i = I2C_FIFO_SIZE;
				len -= i;
			}
			else
			{
				i = len;
				len = 0;
			}

			/* Update expected receive data size*/
#if (DEBUG_PRINT)
			printf("WR TWI_TR_SIZE = 0x%x\n", i);
#endif
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_TR_SIZE, WDC_WRITE, &i, FALSE);

			/* Write device address */
#if (DEBUG_PRINT)
			printf("WR TWI_ADDRESS = 0x%x\n", devAddr);
#endif
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_ADDRESS, WDC_WRITE, &devAddr, FALSE);

			//Wait until it is completed
			j = MAX_RETRY;
			while(j > 0)
			{
				dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_IRT_STATUS, WDC_READ, &tmp, FALSE);
				if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

#if (DEBUG_PRINT)
				printf("RD TWI_IRT_STATUS = 0x%x, ", tmp);
#endif

				if(tmp & 0x1)
					break;
				j--;
			}
			// ERROR, Completion status not detected
			if(j == 0)
			{
				errFlag = TRUE;
				continue;
			}

			// Read data from FIFO
			for(; i > 0; i--)
			{
				dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_DATA, WDC_READ, &tmp, FALSE);
				if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

				*(ptrBuff + totalTransfer) = tmp & 0xFF;
				totalTransfer++;
			}
		}//while(len > 0 && !errFlag)
	}

	return totalTransfer;

}

// Read a single EEPROM word.
// eepromWord is the value from the EEPROM_ENTRY macro.
UINT32 PIXIE500E_ReadI2C_Word(WDC_DEVICE_HANDLE hDev, U32 *eepromWord, UINT32 wordOffset)
{
  
	U32 offset, value, value2;
	UINT8 EEPROMbuffer[EEPROM_WD_SIZE];
	S32 retval = 0;

	offset = wordOffset*EEPROM_WD_SIZE;
	// Read directly from EEPROM
	retval = PIXIE500E_ReadI2C(hDev, EEPROMbuffer, SLAVE_ADDR, offset, EEPROM_WD_SIZE);
	if( retval != EEPROM_WD_SIZE) {
	  sprintf(ErrMSG, "*ERROR* (Pixie_ReadI2C_Word): Error reading EEPROM at offset 0x%x", offset);
	  Pixie_Print_MSG(ErrMSG,1);
	  return(-1);
	}
	value = EEPROMbuffer[0] | (EEPROMbuffer[1] << 8);
	value2 = EEPROMbuffer[2] | (EEPROMbuffer[3] << 8) | (EEPROMbuffer[4] << 16) | (EEPROMbuffer[5] << 24);
	//printf("EEPROM: 0x%04x = 0x%08x\r\n", value, value2);
	*eepromWord = value2;

	return(0);
}

UINT32 PIXIE500E_WriteI2C(WDC_DEVICE_HANDLE hDev, const void *buffer, UINT32 addr, UINT32 offset, UINT32 len)
{
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT8 m_div_a, m_div_b; //Internal Divisor_A and Divisior_B settings


	// From GN RDK, i2c_gn4124.cpp Write()
	UINT32 tmp, i, j, ctl;

	UINT32 totalTransfer=0;
	const UINT8 * ptrBuff = (const UINT8*)(buffer);

	BOOL errFlag = FALSE;

	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;

	// Set default baud rate
	// (div_a+1) * (div_b+1) = Fpciclk / (22 * Fscl)
	m_div_a = 1;
	m_div_b = (PCICLK / (22 * I2C_BAUD_RATE * (m_div_a + 1))) - 1;
	m_div_b &= 0x3F;

	offset &= 0xFF;
	addr &= 0x7F;

#if (DEBUG_PRINT)
	printf("Write to addr 0x%x, offset 0x%x, len 0x%x\n", addr, offset, len);
#endif

	if(hDev && IsItemExists(pDev, ITEM_MEMORY) && len > 0)
	{
		/* Shut off EEPROM_INIT state machine if it is not so */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, LB_CTL, WDC_READ, &i, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (i==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

		if((i & 0x10000) == 0)
		{
			i |= 0x10000;
			dwStatus = PIXIE500E_ReadWriteReg(hDev, LB_CTL, WDC_WRITE, &i, FALSE);
		}

		/* Read to clear TWI_STATUS and TWI_IRT_STATUS */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_IRT_STATUS, WDC_READ, &tmp, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_STATUS, WDC_READ, &tmp, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

		/* Initialize clock */
		/* CLR_FIFO = 1, SLVMON = 0, HOLD = 0, ACKEN = 1, NEA = 1, MS = 1, RW = 0 */
		ctl = (m_div_a << 14) | (m_div_b << 8) | 0x4E;
#if (DEBUG_PRINT)
		printf("WR TWI_CTL = 0x%x\n", ctl);
#endif
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_CTRL, WDC_WRITE, &ctl, FALSE);

		/* Read back from register to guarantee the mode change */
		dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_CTRL, WDC_READ, &ctl, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (ctl==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

		i = MAX_RETRY;
		do
		{
			//Wait until i2c bus is idle
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_STATUS, WDC_READ, &tmp, FALSE);
			if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash

			i--;
		}while((tmp & 0x100) && (i > 0));

		/* Perform sequential page write from the start address */                             
		while(!errFlag && len > 0)
		{
			/* Write word offset */
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_DATA, WDC_WRITE, &offset, FALSE);

			for(i = (I2C_FIFO_SIZE - 1); (i > 0) && (len > 0);)
			{
				/* Write TWI_DATA to start the transfer */
				tmp = *(ptrBuff + totalTransfer);
				dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_DATA, WDC_WRITE, &tmp, FALSE);
				totalTransfer++;
				offset++;       /* Increment address */
				i--;
				len--;

				/* Reaches the page write address boundary, thus need to start
				*                                   the offset at the next page */
				if((offset & (PAGE_SIZE - 1)) == 0)
					break;
			}

			/* Write device address */
			dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_ADDRESS, WDC_WRITE, &addr, FALSE);

			//Wait until it is completed
			j = MAX_RETRY;
			while(j > 0)
			{
				dwStatus = PIXIE500E_ReadWriteReg(hDev, TWI_IRT_STATUS, WDC_READ, &tmp, FALSE);
				if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (tmp==0xFFFFFFFF) ) return WD_WINDRIVER_STATUS_ERROR;		// fatal error causing system crash
#if (DEBUG_PRINT)
				printf("RD TWI_IRT_STATUS = 0x%x,\n", tmp);
#endif

//#if defined (XIA_WINDOZE)
//				Sleep(10);
//#elif defined (XIA_LINUX)
//				usleep(10 * 1000);
//#endif
				Pixie_Sleep(10);

				if(tmp & 0x1)
				{
					break;
				}
				//Time our or NACK has occurred!
				else if(tmp & 0xC)
				{
#if (DEBUG_PRINT)
					printf("NACK detected or TIMEOUT, IRT_STATUS = 0x%x!!\n", tmp);
#endif
					return totalTransfer;
				}
				j--;
			}
		}
	}

	return totalTransfer;
}


UINT32 PIXIE500E_DumpI2CPROM(WDC_DEVICE_HANDLE hDev)
// Dump of EEPROM content
// From GN RDK void InfoDump::EEPROMDump(Logger * hStream, UINT8 addr, UINT32 size)
{
	// KS assuming that EEPROM size and slave address are staying fixed
	// to 256 and 0x56 respectively. Tired of hunting down where they were set
	// in GN RDK app (pretty sure they were only set in constructors
	// to the default values).


	UINT32 i, entries = EEPROM_SIZE / 6;
	UINT32 offset = 0;
	UINT32 value, value2;
	UINT8 buffer[6];
	UINT8 ErrMSG[256];

	printf("----------------------------------\r\n");
	printf("   EEPROM content dump\r\n");
	printf("----------------------------------\r\n");

	for(i = 0; i < entries; i++)
	{
		if(6 != PIXIE500E_ReadI2C(hDev, buffer, SLAVE_ADDR, offset, 6))
		{
			printf("Error reading at offset 0x%x!\r\n", offset);
			break;
		}
		value = buffer[0] | (buffer[1] << 8);
		value2 = buffer[2] | (buffer[3] << 8) | (buffer[4] << 16) | (buffer[5] << 24);

		sprintf(ErrMSG, "EEPROM DUMP%04d: 0x%04x = 0x%08x", (i+1), value, value2);
		Pixie_Print_MSG(ErrMSG,1);
		offset += 6;
	}
	printf("\r\n");

	return WD_STATUS_SUCCESS;
}

// Write a single EEPROM entry.
// E.g. if writing 0x12345678 for register 0xABCD, that should be the 13th entry in EEPROM, use 
// 	unsigned char eepromEntry[6] = {EEPROM_ENTRY(0xABCD, 0x12345678)};
// and then call PIXIE500E_WriteI2C_Word(hDev, eepromEntry,  13).
UINT32 PIXIE500E_WriteI2C_Word(WDC_DEVICE_HANDLE hDev, const UINT8 *eepromEntry, UINT32 wordOffset)
{
	U32 offset;
	S32 retval = 0;

	offset = wordOffset*EEPROM_WD_SIZE;

sprintf(ErrMSG, "*INFO* (Pixie_WriteI2C_Word): Writing 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X to EEPROM at wd.offset %d",eepromEntry[0], eepromEntry[1], eepromEntry[2], eepromEntry[3], eepromEntry[4], eepromEntry[5], wordOffset);
Pixie_Print_MSG(ErrMSG,1);

	// Write directly to EEPROM
	retval = PIXIE500E_WriteI2C(hDev, eepromEntry, SLAVE_ADDR, offset, EEPROM_WD_SIZE);
	if( retval != EEPROM_WD_SIZE) {
	  sprintf(ErrMSG, "*ERROR* (Pixie_WriteI2C_Word): Error writing to EEPROM at offset 0x%x", offset);
	  Pixie_Print_MSG(ErrMSG,1);
	  return(-1);
	}

	return(0);
}

//
// Load the default EEPROM image, as defined in the header file.
//
UINT32 PIXIE500E_LoadDefaultI2CPROM(WDC_DEVICE_HANDLE hDev)
{

	UINT32 i = 0;
	i = PIXIE500E_WriteI2C(hDev, GN4124_EEPROM_DEFAULT, SLAVE_ADDR, 0, EEPROM_SIZE);
	// TODO:  KS the EEPROM_SIZE is really fixed to 256?
	if (i == EEPROM_SIZE ) return WD_STATUS_SUCCESS;
	else return (WD_WINDRIVER_STATUS_ERROR);
}


// 
// Load the .BIN file (combined Virtex and Spartan .bit files) into FPGA using FCL.
// The loading mode is only FCL (no interrupts, bit-banging), and bits are swapped.
//
//UINT32 PIXIE500E_ProgramFPGA(WDC_DEVICE_HANDLE hDev, char const * filename, UINT32 fcl_clk_div)
UINT32 PIXIE500E_ProgramFPGA(WDC_DEVICE_HANDLE hDev, UINT32 fcl_clk_div, UINT32 type) {
#define DEBUG_PRINT 0

	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	UINT32 len;
	UINT8  value;
	UINT32 i, j, k, word_counter = 0, doneInt = 0;
	UINT32 dwData, svData;
	INT16 fcl_irq, fcl_ctrl, fcl_status;
	UINT8 *pu8Ptr;
	UINT8 tmpU8Ptr[4]; // temp buffer for bit-reversed configuration chunks to go in FCL_FIFO_DATA

	sprintf(ErrMSG, "*INFO* (PIXIE500E_ProgramFPGA(): BEGIN");
	Pixie_Print_MSG(ErrMSG,1);

	switch (type) {
		case (UINT32)MODULETYPE_P500e:
			pu8Ptr = P500e_FPGA_Configuration;
			len = N_P500E_BYTES;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): P500e configuration");
			Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
			break;
		case (UINT32)MODULETYPE_P4e_16_125:
			pu8Ptr = P4e_FPGA_Configuration;
			len = N_P4E_BYTES;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): P4e_16_125 configuration");
			Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
// KS DEBUG
//type = 12;
			break;
		case (UINT32)MODULETYPE_P4e_14_500:
			pu8Ptr = P4e14500_FPGA_Configuration;
			len = N_P4E_BYTES;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): P4e_14_500 configuration");
			Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
			break;
		case 12: // Force FPGA re-configuration (test)
			// Hardwired for P4e_16_125
			pu8Ptr = P4e_FPGA_Configuration;
			len = N_P4E_BYTES;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): P4e_16_125 configuration, force re-configuration (type 12)");
			Pixie_Print_MSG(ErrMSG,1);
			break;
		case 13: // Force FPGA re-configuration (test)
			// Hardwired for P4e_14_500
			pu8Ptr = P4e14500_FPGA_Configuration;
			len = N_P4E_BYTES;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): P4e_14_500 configuration, force re-configuration (type 13)");
			Pixie_Print_MSG(ErrMSG,1);
			break;
		default:
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): Unknown Module Type %X", type);
			Pixie_Print_MSG(ErrMSG,1);
			return (-3);//unknown module type;

	} // switch modules type

  //tricks to allow FPGA reboot ...does not seem to help. PLL reset from Igor before boot _sometimes_ works
	// but turn on anyway, sometimes DSP can't boot because of PLL and this will rested for the next try
	// force a PLL reset via the CLK_CSR -- else FPGA will lock up in second reboot
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);		// read clk csr
	if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): Problem reading CLK_SCR=0x%08X", dwData);
		Pixie_Print_MSG(ErrMSG,1);
		return REGIO_ERR;		// fatal error causing system crash
	}

	sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA): read CLK CSR 0x%08X.",dwData);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);


	// check if FPGA already booted. If so, print warning and do nothing
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_STATUS, WDC_READ, &fcl_status, FALSE);
	if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (fcl_status==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash

//	sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA(): FCL_STATUS=0x%04X, Done=%d", fcl_status, (fcl_status&0x8)/8);
//	Pixie_Print_MSG(ErrMSG,1);    
	if((fcl_status & 0x8) == 0x8){ // if already configured
		if(type==12 || type==13) {
			sprintf(ErrMSG, "*WARNING* (PIXIE500E_ProgramFPGA(): FPGA already programmed, BUT NOW REPROGRAMMING (debug mode)");
			Pixie_Print_MSG(ErrMSG,1); 
		} 
		else {
			sprintf(ErrMSG, "*WARNING* (PIXIE500E_ProgramFPGA(): FPGA already programmed, skipping. Power cycle chassis to reprogram");
			Pixie_Print_MSG(ErrMSG,1);  
			PIXIE4E_FPGApostboot_IO(hDev);
			return (dwStatus);
		}
	}

	// Force DSP reset, in case it holds some config lines down. Doesn't seem to help
	// KS DEBUG: but this BAR0 I/O might lead to problems on re-configuration.
	// Commenting out.
	//dwData = 0x0;
	//dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_WRITE, &dwData, FALSE);
	//// Read it just in case
	//// dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_READ, &dwData, FALSE);
	////if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash
	////sprintf(ErrMSG, "*INFO*(PIXIE500E_ProgramDSP): APP_HOST_CTL = %x",dwData );
	////Pixie_Print_MSG(ErrMSG,1);
	//Pixie_Sleep(150);

	// Assert RSTOUT
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	i &= ~(0xC000);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//Read back to ensure write completion
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);

	// Disable Local Bus
	i &=~(0x3000); 
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//Read back to ensure write completion
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);

	// PERFORM FPGA Configuration Loader routine.

	/* Set FCL_CLK_DIV */
	i = 0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CLK_DIV , WDC_WRITE, &i, FALSE);

	/*  Reset FCL */
	fcl_ctrl = 0x40;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_WRITE, &fcl_ctrl, FALSE);

	/* Read back to ensure FCL block is operational */
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_READ, &fcl_ctrl, FALSE);

	if( fcl_ctrl != 0x40 ) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): Error in FCL_CTL=0x%04X", fcl_ctrl);
		Pixie_Print_MSG(ErrMSG,1);
		return (-4);//WD_WINDRIVER_STATUS_ERROR;
	}

	fcl_ctrl = 0x0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_WRITE, &fcl_ctrl, FALSE);

	/* Clear IRQ */
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_IRQ, WDC_READ, &fcl_irq, FALSE);

	/* Enable FSM and FPGA Configuration mode */
	fcl_ctrl = 0x106;

	/* Set last word byte length */
	i = len % 4;
	if(i == 3)
		fcl_ctrl |= 0x10;
	else if(i == 2)
		fcl_ctrl |= 0x20;
	else if(i == 1)
		fcl_ctrl |= 0x30;

	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_WRITE, &fcl_ctrl, FALSE);

	/* Set clock divider.  PCLK at 125Mhz */
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CLK_DIV, WDC_WRITE, &fcl_clk_div, FALSE);


	/* Disable FCL timer function for FSM mode of operation */
	i = 0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_TIMER_CTRL, WDC_WRITE, &i, FALSE);

	/* Set pulse width of SPRI_CONFIG signal in terms of FCL clock cycles.
	*	Requires minimum of 500ns for FPGA in Xilinx Spartan-3A family.
	*/
	// TODO: KS, check if these timings are ok for Virtex.
	i = 16;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_TIMER_0, WDC_WRITE, &i, FALSE);

	i = 0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_TIMER_1, WDC_WRITE, &i, FALSE);

	/* Set delay before data and clock is applied by FCL after SPRI_STATUS is
	*	detected being assert.
	*/
	i = 8;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_TIMER2_0, WDC_WRITE, &i, FALSE);

	i = 0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_TIMER2_1, WDC_WRITE, &i, FALSE);

	/*  Set FCL output enable */
	i = 0x17;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_EN, WDC_WRITE, &i, FALSE);

	//Starts FSM configuration
	fcl_ctrl |= 0x1;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_WRITE, &fcl_ctrl, FALSE);

	while(len > 0) { // load configuration
		// Check to see if FPGA configuation has error
		dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_IRQ, WDC_READ, &fcl_irq, FALSE);

		//sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA(): FCL_IRQ = 0x%04X len=%ld", fcl_irq, len);
		//Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

		if((fcl_irq & 0x8) && (word_counter > 0))
		{
			doneInt = 1;
			//sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA(): CONFIG_DONE detected!");
			//Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
		}
		else if((fcl_irq & 0x4) && !doneInt)
		{
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): FCL reset on write error detected!");
			Pixie_Print_MSG(ErrMSG,1);
			return(-5);// WD_WINDRIVER_STATUS_ERROR;
		}

		//Write 128 dwords into FIFO at a time.
		for(i = 0; (i < 128) && (len > 0); i++, word_counter++)
		{
		// Bit reorder each byte of the file content.  This is required for Xilinx
		// FPGA's PROM file.
			for (k = 0; k < 4; k++) { // 4 U8 words to put in j
				value = *(pu8Ptr + k);
				value = ((value & 0x80) >> 7 |
					((value & 0x40) >> 5) |
					((value & 0x20) >> 3) |
					((value & 0x10) >> 1) |
					((value & 0x08) << 1) |
					((value & 0x04) << 3) |
					((value & 0x02) << 5) |
					((value & 0x01) << 7));
				tmpU8Ptr[k] = value;
			}
			memcpy(&j, tmpU8Ptr, 4);

			pu8Ptr += 4;
			dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_FIFO_DATA, WDC_WRITE, &j, FALSE);

			//if (len<=218) {
			//	sprintf(ErrMSG, "*DEBUG* (PIXIE500E_ProgramFPGA():  FCL_FIFO_DATA=0x%08X", j);
			//	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
			//}

			if(len > 4)
				len -= 4;
			else
				len = 0;
		}
	} // while loading configuration, len >0

	//Assert last data word written flag
	fcl_ctrl = 0x186;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_CTRL, WDC_WRITE, &fcl_ctrl, FALSE);

	i = 0;
	/* Wait for DONE interrupt  */
	while(!doneInt) {
		dwStatus = PIXIE500E_ReadWriteReg(hDev, FCL_IRQ, WDC_READ, &fcl_irq, FALSE);

		if(fcl_irq & 0x8)
			doneInt = 1;
		else if((fcl_irq & 0x4) && !doneInt) {
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): ERROR 6 detected!");
			Pixie_Print_MSG(ErrMSG,1);
			return(-6);// WD_WINDRIVER_STATUS_ERROR;
		}

		if(i++ > PIXIE500E_FCL_TIME_OUT){
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): TIMEOUT on waiting DONE interrupt! FCL_IRQ=0x%04X dwStatus=%ld", fcl_irq, dwStatus);
			Pixie_Print_MSG(ErrMSG,1);                 
			return(-7);// WD_WINDRIVER_STATUS_ERROR;
		}
	} // while not done

	sprintf(ErrMSG, "*INFO* (PIXIE500E_ProgramFPGA): Configuration done.");
	Pixie_Print_MSG(ErrMSG,1);

	// Enable Local Bus
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	i |=0x1000; 
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//Read back to ensure write completion
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	Pixie_Sleep(1500); // This delay is EXTREMELY critical for SDRAM calibration!!! (500 seems OK)
	// De-assert RSTOUT
	i |= 0x4000;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//Read back to ensure write completion
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);

	Pixie_Sleep(500); // because the reset goes on for ~150ms! critical for proper end run?

	// NOTE: At this point we see that PLL is always locked (or 0xF), but APP_SDRAM_STATUS
	// comes out as 0x0 or 0xF, while logic analyzer shows correct values (0x4) going to Gennum.
	// It is still not clear, why on some re-configurations we are losing BAR4/BAR0.

	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): assume BAR0 problems, doing PLL reset...");
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
	PIXIE500E_LBClkReset(hDev);
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): got BAR0 back?");
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
	//}

	// check if GN PLL locked
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);
	if ((dwData & 0xF0000000) != 0xE0000000) {
		sprintf(ErrMSG, "*ERROR*(PIXIE500E_ProgramFPGA): Problem with PLL lock, CLK_CSR=0x%08X. Please reboot", dwData);
		Pixie_Print_MSG(ErrMSG,1);
		return(-4);
	}
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): PLL is locked, CLK_CSR=0x%08X", dwData);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

	// When forcing re-configuration, losing BAR0 here (CID changed to 1 on re-configuration)

	// Read from BAR0
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): checking BAR0:");
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCIE_BAR0_LOW, WDC_READ, &i, FALSE);
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): (BAR4) PCIE_BAR0_LOW = 0x%08X ", i);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

	dwStatus = PIXIE500E_ReadWriteReg(hDev, PL_WR_BRG_RD_THRES, WDC_READ, &i, FALSE);
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): PL_WR_BRG_RD_THRES = 0x%08X ", i);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

	// check if SDRAM initialized
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_READ, &i, FALSE);
	sprintf(ErrMSG, "*DEBUG*(PIXIE500E_ProgramFPGA): APP_SDRAM_STATUS = 0x%08X ", i);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);



	dwStatus= PIXIE4E_FPGApostboot_IO(hDev);
	if(dwStatus !=0) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramFPGA(): PIXIE4E_FPGApostboot_IO failed");
		Pixie_Print_MSG(ErrMSG,1);  
		return (dwStatus);
	}

	sprintf(ErrMSG, "*INFO* (PIXIE500E_ProgramFPGA(): END");
	Pixie_Print_MSG(ErrMSG,1);
	return 0;
}

UINT32 PIXIE4E_FPGApostboot_IO(WDC_DEVICE_HANDLE hDev) {

	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	UINT32 i, k, dwData;

	Pixie_Sleep(10); // to let clocks settle


//
//	// ***********************************************************
//	// apply default settings for some configuration registers
//	// ***********************************************************
//
///*	// force a PLL reset via the CLK_CSR -- else FPGA will lock up in second reboot
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);		// read clk csr
//	if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash
//
//	sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA): read CLK CSR %x.",dwData);
//	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
//	svData = dwData;
//	dwData = dwData | (U32)(pow(2.0,27));												// set reset bit
////	sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA): write CLK CSR %x.",dwData);
////	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &dwData, FALSE);		// write
//	Pixie_Sleep(150);
//	dwData = svData;
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &dwData, FALSE);	// write without reset
//	Pixie_Sleep(150);
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);		// read clk csr
////	sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA): read CLK CSR %x.",dwData);
////	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
//	if((dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) {
//		sprintf(ErrMSG, "*DEBUG* (PIXIE4E_ProgramFPGA): CLK_CSR read failed, aborting");
//		Pixie_Print_MSG(ErrMSG,1);
//		return (REGIO_ERR);
//	}
//	Pixie_Sleep(200);	// reset takes ~150ms  */
//	
	// Switch off test pattern generator for DMA reads (replacing SDRAM data)
	// (clear bit zero would read counter test patterns, counter incrementing on each read)
	i = 1;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_CFG, WDC_WRITE, &i, FALSE);
	Pixie_Sleep(10);
	// now off by default


	// check if GN PLL locked
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);
	if ((dwData & 0xF0000000) != 0xE0000000) {
		sprintf(ErrMSG, "*ERROR*(PIXIE4E_FPGApostboot_IO): Problem with PLL lock, CLK_CSR=0x%08X. Please reboot", dwData);
		Pixie_Print_MSG(ErrMSG,1);
		return(-4);
	}
	sprintf(ErrMSG, "*DEBUG*(PIXIE4E_FPGApostboot_IO): PLL is locked, CLK_CSR=0x%08X", dwData);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);

//	/* // Reset PDM and LDM block 
//	i = 0x1F;
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, DMA_CFG, WDC_WRITE, &i, FALSE);
//	if(dwStatus != WD_STATUS_SUCCESS)
//	{
//		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init): reset %x", i);
//		Pixie_Print_MSG(ErrMSG,1);
//		return (REGIO_ERR);
//	}
//
//	i = 0x7;
//	dwStatus = PIXIE500E_ReadWriteReg(hDev, DMA_CFG, WDC_WRITE, &i, FALSE);
//	if(dwStatus != WD_STATUS_SUCCESS)
//	{
//		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init):  shifts %x", i);
//		Pixie_Print_MSG(ErrMSG,1);
//		return (REGIO_ERR);
//	} */
//
	// Switch off test pattern generator for DMA reads (replacing SDRAM data)
	// (clear bit zero would read counter test patterns, counter incrementing on each read)
	//i = 1;
	//dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_CFG, WDC_WRITE, &i, FALSE);
	//Pixie_Sleep(10);
	// now off by default
	
	// check if SDRAM initialized
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_READ, &i, FALSE);
	sprintf(ErrMSG, "*DEBUG*(PIXIE4E_FPGApostboot_IO): APP_SDRAM_STATUS = 0x%08X ", i);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
	if ( (i & 0x4) >> 2 == 0) { // if SDRAM INIT_DONE is not set, need to calibrate
		sprintf(ErrMSG, "*ERROR*(PIXIE4E_FPGApostboot_IO): SDRAM INIT_DONE is not set, APP_SDRAM_STATUS = 0x%x ", i);
		Pixie_Print_MSG(ErrMSG,1);
		return(-4);
	}

	return 0;

}

// Do local bus PLL test (copied from LBClkTest.cpp of GN RDK
// NOTE: after FPGA re-configuration reading BAR0 leads to a hard crash.
// However, as checked with GenDiag, running LBClkTest Unit Test somehow
// fixes the BAR0 problem. So, will try to run it after re-configuration
void PIXIE500E_LBClkReset(WDC_DEVICE_HANDLE hDev)
{
	UINT32 originalSettings, postRefClk, dwStatus, i, tmp;
	UINT16 divOut, divFB, divIn, l_pll_range;
	UINT64 vco, lclk;

	const int m_refClk = 25000000; // 25 MHz oscillator


	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &originalSettings, FALSE);


	// NOTE: Seems like setting PLL to different values is not needed to recover BAR0,
	// the loops over divIn, divFB, divOut commented out.
	//
	//for (divIn = 0; divIn < 0x80; divIn++) {
	//	postRefClk = m_refClk / (divIn + 1);
	//	// Try next difIn value if either refclk/divIn ratio not met or divIn is not 0
	//	if (postRefClk < MIN_REFCLK_DIVIN_RATIO || postRefClk > MAX_REFCLK_DIVIN_RATIO)
	//		continue;
	//	for (divFB = 0; divFB < 0x80; divFB++) {
	//		vco = (UINT64)m_refClk * (UINT64)(divFB + 1) / (UINT64)(divIn + 1);
	//		// VCOout must be between 500 MHz and 1 GHz
	//		if (vco < (UINT64)MIN_VCO || vco > (UINT64)MAX_VCO)
	//			continue;
	//		for (divOut = 0; divOut < 0x40; divOut++) {
	//			lclk = vco / (UINT64)(divOut + 1);
	//			if (lclk < (UINT64)MIN_LCLK || lclk > (UINT64)MAX_LCLK)
	//				continue;
	//			if (postRefClk >= 88000000 && postRefClk < 200000000)
	//				l_pll_range = 7;
	//			else if (postRefClk >= 54000000 && postRefClk <= 108000000)
	//				l_pll_range = 6;
	//			else if (postRefClk >= 34000000 && postRefClk <= 68000000)
	//				l_pll_range = 5;
	//			else if (postRefClk >= 21000000 && postRefClk <= 42000000)
	//				l_pll_range = 4;
	//			else if (postRefClk >= 13000000 && postRefClk <= 26000000)
	//				l_pll_range = 3;
	//			else if (postRefClk >= 8000000 && postRefClk <= 16000000)
	//				l_pll_range = 2;
	//			else if (postRefClk >= 5000000 && postRefClk <= 10000000)
	//				l_pll_range = 1;
	//			else 
	//				l_pll_range = 0;
	//			// Assert RSTOUT
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	//			i &= ~(0xC000);
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	//			
	//			// new settings
	//			tmp = ((divOut << 4) | (divFB << 12) | (divIn << 20) | 0x8080008 | l_pll_range) & 0xFFFFFFF;
	//			sprintf(ErrMSG, "*DEBUG* (LBClkReset): LCLK = %ld, L_PLL_RANGE=%d, DivOut=%d, DivFB=%d, DivIn=%d...", lclk, l_pll_range, divOut, divFB, divIn);
	//			Pixie_Print_MSG(ErrMSG,1);
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &tmp, FALSE);
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &tmp, FALSE);
	//			Pixie_Sleep(500);
	//			// Take PLL out of reset
	//			tmp &= (~0x8080000) & 0xFFFFFFF;
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &tmp, FALSE);
	//			// Check PLL and P2L DLL lock
	//			for (i = 0; i < 10; i++) {
	//				dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &tmp, FALSE);
	//				if ((tmp & 0xC0000000)==0xC0000000) break;
	//				Pixie_Sleep(50);
	//			}
	//			if ((tmp & 0xC0000000) !=0xC0000000) {
	//				i = (vco & 0xFFFFFFFF);
	//				sprintf(ErrMSG, "*ERROR* (LBClkReset): Failed, VCO=%d, PLL_LOCK=%d, P2L_LOCK=%d, L2P_LOCK=%d", i, ((tmp & 0x80000000)==0x80000000), ((tmp & 40000000)==0x40000000), ((tmp & 20000000)==0x20000000));
	//				Pixie_Print_MSG(ErrMSG,1);
	//				continue;
	//			}
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	//			i |= 0x5000;
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	//			//Read back to ensure write completion
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	//			Pixie_Sleep(500);
	//			// Check L2P DLL status
	//			dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &tmp, FALSE);
	//			if ((tmp & 0xE0000000) !=0xE0000000) {
	//				i = (vco & 0xFFFFFFFF);
	//				sprintf(ErrMSG, "*ERROR* (LBClkReset): Failed, VCO=%d, PLL_LOCK=%d, P2L_LOCK=%d, L2P_LOCK=%d", i, ((tmp & 0x80000000)==0x80000000), ((tmp & 40000000)==0x40000000), ((tmp & 20000000)==0x20000000));
	//				Pixie_Print_MSG(ErrMSG,1);
	//			}
	//			else {
	//				sprintf(ErrMSG, "*DEBUG* (LBClkReset): passed");
	//				Pixie_Print_MSG(ErrMSG, 1);
	//			}
	//		} // for divOut
	//	} // for divFB
	//} // for divIn


	// Actually, here is all that is needed to get BAR0 back:
	sprintf(ErrMSG, "*DEBUG* (LBClkReset): disable bus...");
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);
	// Assert RSTOUT
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	i &= ~(0xC000);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);	//Read back to ensure write completion
	
	sprintf(ErrMSG, "*DEBUG* (LBClkReset): settings: 0x%08X ...", originalSettings);
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);

	originalSettings |= 0x8080000;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &originalSettings, FALSE);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &originalSettings, FALSE);		//Read back to ensure write completion	
	originalSettings &= ~0x8080000;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_WRITE, &originalSettings, FALSE);
	sprintf(ErrMSG, "*DEBUG* (LBClkReset): writing 0x%08X", originalSettings);
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);
	Pixie_Sleep(500);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &originalSettings, FALSE);	//Read back to ensure write completion
	sprintf(ErrMSG, "*DEBUG* (LBClkReset): reading 0x%08X", originalSettings);
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);

	sprintf(ErrMSG, "*DEBUG* (LBClkReset): enable bus...");
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);

	// De-assert RSTOUT. Enable Local Bus.
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);
	i |= 0x1000;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);	//Read back to ensure write completion
	Pixie_Sleep(1500);
	i |= 0x4000;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_WRITE, &i, FALSE);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, PCI_SYS_CFG_SYSTEM, WDC_READ, &i, FALSE);	//Read back to ensure write completion
	Pixie_Sleep(1500);

	sprintf(ErrMSG, "*DEBUG* (LBClkReset): DONE.");
	Pixie_Print_MSG(ErrMSG, PrintDebugMsg_Boot);

}

// Initialize DMA: generate Scatter-gather list for the given buffer.
// Generage VDMA code, program DMA sequencer. Done once, maybe upon boot.
// Init DMA (reset program pointer, interrupts, flags) for this frame buffer. Upon RUN_START.
// *** Engine active
// VDMA_Driver_Go(): upon signal from host. Or event from DSP. Data to host, page at a time.
//
// Signal host complition of DMA transfer, or host polls the DMA status register
// (pretty much the same as DMA_WaitForCompletion().)
// That could be in Pixie_IODM(): data could be already on the host: just need to save it.
//
// Once host took care of this frame buffer, reset program pointer to start. Upon old RESUME_RUN.
// Sequencer could reset the program pointer, number of pages to send automatically.
// *** Engine done: on RUN_STOP. Don't really do anything.
//
// Clean out the transfer buffer, free SG list: upon closing, LibUninit.
//
// Make sure that can deal with multiple modiles: DMA structures for different hDev.

UINT32 PIXIE500E_DMA_Trace_Setup (WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize, DWORD *dwDMABuffer, WD_DMA **ppDmaL2P)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	UINT32 i, j, tmp;
	INT32 *pCodeBuffer;

	//sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Trace_Setup): Starting DMA setup...");
	//Pixie_Print_MSG(ErrMSG,1);

	// Allocate and clear buffer for the DMA sequencer code
	pCodeBuffer = (INT32*) malloc(m_RAMSize);
	if (!pCodeBuffer) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_DMA_SDRAM_Trace) Failed to allocate memory for pCodeBuffer");
		Pixie_Print_MSG(ErrMSG,1);
		return (WD_WINDRIVER_STATUS_ERROR);
	}
	memset(pCodeBuffer, 0, m_RAMSize);

	// Lock DMA buffer
	// Try Scatter Gather first
	//sprintf(ErrMSG, "*DEBUG* (PIXIE500E_DMA_Trace_Setup): Size of buffer %X (%d)", dwDMABufSize,dwDMABufSize);
	//Pixie_Print_MSG(ErrMSG,1);
	dwStatus = WDC_DMASGBufLock(hDev, dwDMABuffer, DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS, dwDMABufSize, ppDmaL2P);
	if (dwStatus != WD_STATUS_SUCCESS) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_DMA_Trace_Setup): Failed to lock Scatter Gather DMA buffer, status=0x%08X", dwStatus);
		Pixie_Print_MSG(ErrMSG,1);
		return (dwStatus);
	}	

	// Construct VMDA sequencer code from the DMA structures.
	PIXIE500E_VDMACodeGen_TraceOut(hDev, pCodeBuffer, *(ppDmaL2P));
	
	//// DEBUG pages
	//tmp = 0;
	//for (i = 0; i < (*ppDmaL2P)->dwPages; i++) {
	//	sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Trace_Setup) L2P Page %i, len = %d @ 0x%08X", i, (*ppDmaL2P)->Page[i].dwBytes, (*ppDmaL2P)->Page[i].pPhysicalAddr);
	//	Pixie_Print_MSG(ErrMSG,1);
	//	tmp+= (*ppDmaL2P)->Page[i].dwBytes;
	//}
	//sprintf(ErrMSG, "*DEBUG* L2P pages total= %d", tmp);
	//Pixie_Print_MSG(ErrMSG,1);
	
	// Program the sequencer.
	dwStatus = PIXIE500E_DMA_ProgramSequencer(hDev, pCodeBuffer);

	if (dwStatus!=WD_STATUS_SUCCESS) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_DMA_Trace_Setup) Failure to program DMA controller");
		Pixie_Print_MSG(ErrMSG,1);
		return dwStatus;
	}

	free(pCodeBuffer);
	return (dwStatus);
}







void PIXIE500E_VDMACodeGen_TraceOut(WDC_DEVICE_HANDLE hDev,  const void *pCodeBuffer, const WD_DMA *pDmaL2P)
{

	UINT64 kernelAddrL2P;
	UINT32 i, j, pagesL2P, pageLength;

	UINT32 * buffPtr = (UINT32*) pCodeBuffer;
	UINT32 rep4K;


	// ************************** Sequencer code BEGIN *********************************
	// The idea is to do P2L first, executing non-4K, then some 4K-aligned pages, then non-4K leftover.
	// See pixie500e_lib.h for definitions of the constants

	*(buffPtr + CONST_0) = 0xDEADBEEF; // 0
	*(buffPtr + CONST_NEG_1) = -1; // -1
	*(buffPtr + CONST_SG_LIST_SIZE) = SG_ENTRY_SIZE; // set to 3: addr low, addr high, xfer_ctl

	// TODO: clear events or nop?
	*(buffPtr + MAIN_START) = VDMA_SIG_EVENT(0, 0, 0xFFFF); // Clear all event bits
	*(buffPtr + MAIN_START + 1) = /*VDMA_NOP();*/VDMA_JMP(0x7, 0x22, (MAIN_START+1));  // debug. Wait for data available in SDRAM. Need this???
	// L2P SG processing	
	*(buffPtr + MAIN_START + 2) = VDMA_LOAD_RA(LDM_SG_CNT); // Load into RA remaining L2P transfers (initially set to number of L2P pages)
	*(buffPtr + MAIN_START + 3) = VDMA_JMP(_RA_EQZ, 0, (MAIN_START + 13)); // if L2P transfers == 0, bail out
	*(buffPtr + MAIN_START + 4) = VDMA_LOAD_RB(LDM_SG_LIST_PTR); // Load into RB current L2P base pointer (initially set to start of L2P SG list)
	// BEGIN L2P
	// TODO: jump to end of stay here??? Comparing with GenDiag: should stay here, wait until DMA transfer is done.
	*(buffPtr + MAIN_START + 5) = VDMA_JMP(_LDM_CMD_QUEUE_FULL_HI, 0, (MAIN_START + 5)); // if LDM_CMD_QUEUE is full jump to BEGIN L2P (wait here)
		//*(buffPtr + MAIN_START + 5) = VDMA_JMP(_LDM_CMD_QUEUE_FULL_HI, 0, (MAIN_START + 13)); // if LDM_CMD_QUEUE is full jump to end
	*(buffPtr + MAIN_START + 6) = VDMA_LOAD_SYS_ADDR(_RB, 0); // Load L2P sys_addr from current L2P base pointer
	*(buffPtr + MAIN_START + 7) = VDMA_LOAD_XFER_CTL(_RB, 2); // Load, start L2P xfer_ctl from current L2P base pointer
	*(buffPtr + MAIN_START + 8) = VDMA_ADD_RA(CONST_NEG_1); // decrement L2P transfer count
	*(buffPtr + MAIN_START + 9) = VDMA_ADD_RB(CONST_SG_LIST_SIZE); // advance L2P base pointer by SG_ENTRY_SIZE
	*(buffPtr + MAIN_START + 10) = VDMA_JMP(_RA_NEQZ, 0, (MAIN_START + 5)); // if L2P transfer count !=0 proceed to next SG entry, to BEGIN L2P
	// RA gets the initial LDM_SG_CNT (equal to total number of L2P pages), and then is decremented in a loop until all pages are done.
	// On the next frame buffer host rewinds the sequencer to MAIN_START, but does not reprogramms it, so we still want
	// for the LDM_SG_CNT to hold the same total number of L2P pages, so in MAIN_START+11 now just have a NOP.
	*(buffPtr + MAIN_START + 11) = VDMA_NOP();//VDMA_STORE_RA(LDM_SG_CNT); // zero out the LDM_SG_CNT (in case if we are jumping back to MAIN_START, to next frame buffer
	*(buffPtr + MAIN_START + 12) = VDMA_JMP(_EXT_COND_LO, _LDM_IDLE, (MAIN_START + 12)); // Wait here until LDM goes idle
	// DONE 
	// TODO: check IRQ functionality!
	*(buffPtr + MAIN_START + 13) = VDMA_SIG_EVENT(1, 1, 0x8); // Assert event 0x8
	//*(buffPtr + MAIN_START + 13) = VDMA_SIG_EVENT(1, 1, 0x0); // Stop VDMA
	// ************************** Sequencer code END *********************************
	
	// **************** GENERATE SG LIST DATA *********************
	pagesL2P = 0;
// On Linux sometimes the page size is more than 4K, but the xfer_ctrl maximum is 4K, so the transfers would have to be split into 4K chunks

	*(buffPtr + LDM_SG_LIST_PTR) = DATA_SECTION_START; //  L2P SG entries only
	if (pDmaL2P->dwPages > 0) {
		for (i = 0; i < pDmaL2P->dwPages; i++) {
			//sprintf(ErrMSG, "Page %i, Write request payload size = %d",i, pDmaL2P->Page[i].dwBytes);
			//Pixie_Print_MSG(ErrMSG,1);

			if (pDmaL2P->Page[i].dwBytes > 0 && pDmaL2P->Page[i].dwBytes <= 4096 ) { // if less or equal than 4K page
				rep4K = 1;
				pageLength = pDmaL2P->Page[i].dwBytes;
				//sprintf(ErrMSG,"*INFO* (PIXIE500E_VDMACodeGen_TraceOut): normal page, length=%d", pageLength);
				//Pixie_Print_MSG(ErrMSG,1);
				//Pixie_Sleep(1000);
			} // end if less or equal than 4K page
			else { // if big page
				rep4K = (pDmaL2P->Page[i].dwBytes)/4096;
				pageLength = 0; // 0 in xfer_ctl means 4096 bytes
				//sprintf(ErrMSG,"*INFO* (PIXIE500E_VDMACodeGen_TraceOut): big page, length=%d", pageLength);
				//Pixie_Print_MSG(ErrMSG,1);
				//Pixie_Sleep(1000);
			} // end if big page


			// Generate SG entry
			for (j = 0; j < rep4K; j++) {
				//sprintf(ErrMSG,"*INFO* (PIXIE500E_VDMACodeGen_TraceOut): SG entry,  %d of rep4K=%d", j, rep4K);
				//Pixie_Print_MSG(ErrMSG,1);
				//Pixie_Sleep(1000);
				// Construct 64 bit page address
				//TODO: should use pDmaL2P->pUserAddr?
				kernelAddrL2P = pDmaL2P->Page[i].pPhysicalAddr + j*4096;
				// Generate SG entry 
				*(buffPtr + DATA_SECTION_START + pagesL2P*SG_ENTRY_SIZE) = (UINT32)(kernelAddrL2P & 0xFFFFFFFF); // SYS_ADDR_L
				*(buffPtr + DATA_SECTION_START + pagesL2P*SG_ENTRY_SIZE + 1) = (UINT32)((kernelAddrL2P >> 32) & 0xFFFFFFFF); // SYS_ADDR_H
				*(buffPtr + DATA_SECTION_START + pagesL2P*SG_ENTRY_SIZE + 2) = VDMADriver_CreateXferCtlInstruction(hDev, 0, 1, 0, pageLength); // XFER_CTL
				//sprintf(ErrMSG, "\t\txfer_ctl=0x%X", VDMADriver_CreateXferCtlInstruction(hDev, 0, 1, 0, pageLength));
				//Pixie_Print_MSG(ErrMSG,1);

				pagesL2P++;
			} // do once for less or equal than 4K page, repeat if big page
		} // cycle over pages
		*(buffPtr + LDM_SG_CNT) = pagesL2P;
	} // end L2P

	//sprintf(ErrMSG, "*DEBUG* (PIXIE500E_VDMACodeGen_TraceOut) pagelength %d",pageLength);
	//Pixie_Print_MSG(ErrMSG,1);
} // PIXIE500E_VDMACodeGen_TraceOut end




// Program VDMA sequencer
UINT32 PIXIE500E_DMA_ProgramSequencer(WDC_DEVICE_HANDLE hDev, INT32 *m_CodeBuff)
{
	UINT32 dwStatus, i, j;

	if(!VDMADriver_isIdle(hDev))
	{
		VDMADriver_Halt(hDev);
	}

	// Write the sequencer code into descriptor RAM 
	//	dwStatus = m_PCIAccessor->BlockWriteMemoryAddrSpace(m_PCIBar, m_RAMBase, m_CodeBuff, m_RAMSize);
	// 09/20/13 keep getting comparison errors. Maybe the Block Addr write is not working right. 
	dwStatus = WDC_WriteAddrBlock(hDev, AD_PCI_BAR0, m_RAMBase, m_RAMSize, m_CodeBuff, WDC_MODE_32, WDC_ADDR_RW_DEFAULT);


	// Verify the written data is correct 
	for(i = 0; i < m_RAMSize/sizeof(INT32); i++)
	{
		dwStatus = WDC_ReadAddr32(hDev, AD_PCI_BAR0, (m_RAMBase + i*sizeof(INT32)), &j); 

		if(dwStatus == WD_STATUS_SUCCESS && memcmp(&j, (m_CodeBuff+i), sizeof(UINT32)) != 0)
		{
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_DMA_ProgramSequencer): Comparison error at offset 0x%x! : read 0x%08X; expect 0x%08X\n", i, j, *(m_CodeBuff+i));
			Pixie_Print_MSG(ErrMSG,1);
			return WD_WINDRIVER_STATUS_ERROR;
		}
	}

	return WD_STATUS_SUCCESS;
}

//
// Wait for the DMA transaction to complete:
// If polling just wait for a while until VDMA is idle, then bail out.
// If not polling (using interrupts): catch interrupt (has to be set up in the sequencer)
// Or dont' do anything?

DWORD PIXIE500E_DMA_WaitForCompletion(WDC_DEVICE_HANDLE hDev, BOOL fPolling)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR; 
	DWORD i = 0;
	DWORD dwData = 0;
	const int timeoutDMAms = 4000;	// ~4s required for ADC calibration. Other processes finish much faster
	if (fPolling) {
		while (!VDMADriver_isIdle(hDev) && i < (timeoutDMAms/10)) {
			Pixie_Sleep(10);
			i++;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_DMA_WaitForCompletion): poll %d of %d", i, timeoutDMAms/10);
			Pixie_Print_MSG(ErrMSG,PrintDebugMsg_other);
		}
		dwStatus = WD_STATUS_SUCCESS;

		if (i >= (timeoutDMAms/10)) { // more than normal wait time elapsed, bail out
			VDMADriver_Halt(hDev);
			dwStatus = WD_WINDRIVER_STATUS_ERROR;
			sprintf(ErrMSG, "*DEBUG* (PIXIE500E_DMA_WaitForCompletion): Timeout in wait loop, halting DMA");
			Pixie_Print_MSG(ErrMSG,1);

			
		}
	}
	else {
		sprintf(ErrMSG, "*DEBUG* (PIXIE500E_DMA_WaitForCompletion): Interrupts are not implemented yet");
		Pixie_Print_MSG(ErrMSG,1);
		return(WD_WINDRIVER_STATUS_ERROR);
	}

	return (dwStatus);
}

UINT32 PIXIE500E_DMA_Init(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	UINT32 i, val;

	VDMADriver_SetDPTR(hDev, MAIN_START);
	// KS DEBUG interrupts via GPIO
	VDMADriver_SetEventEnable(hDev, 0xFFFFFFFF); // Event emitted by the sequencer

	//	VDMADriver_SetEventEnable(hDev, 0x400); // to clear SDRAM I/O FIFOs
	//VDMADriver_SetEventEnable(hDev, 0x80); // Event 7 is signal polled by host that frame buffer is done
	VDMADriver_EventClear(hDev, 0xFFFFFFFF);

	Pixie_Sleep(10);
	dwStatus =	PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_READ, &i, FALSE);
	val = i | 0x18;	//Re-init SDRAM (bit 3), clear FIFO (bit 4) 
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_WRITE, &val, FALSE);		// supposedly bit 3 is cleared by next write
	Pixie_Sleep(10);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_WRITE, &i, FALSE);		// so do a write, which also clears it explicitely

	VDMADriver_SetEventEnable(hDev, 0x400); // to clear SDRAM I/O FIFOs

	// Reset PDM and LDM block 
	i = 0x1F;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, DMA_CFG, WDC_WRITE, &i, FALSE);
	if(dwStatus != WD_STATUS_SUCCESS)
	{
		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init): reset %x", i);
		Pixie_Print_MSG(ErrMSG,1);
	}

// KS DEBUG shifts in DMA data
	i = 0x7;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, DMA_CFG, WDC_WRITE, &i, FALSE);
	if(dwStatus != WD_STATUS_SUCCESS)
	{
		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init):  shifts %x", i);
		Pixie_Print_MSG(ErrMSG,1);
	}


	dwStatus = WD_STATUS_SUCCESS; // should really check every write

	// DEBUG
	// Check setup for DRAM test
	dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_READ, &i, FALSE);
	//sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init): SDRAM STATUS: at register 0x80: 0x%08X", i);
	//Pixie_Print_MSG(ErrMSG,1);
	if(dwStatus != WD_STATUS_SUCCESS)
	{
		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init):  check SDRAM status %x", i);
		Pixie_Print_MSG(ErrMSG,1);
	}

	if ( (i & 0x4) >> 2 == 0) { // if SDRAM INIT_DONE is not set, need to calibrate
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_CFG, WDC_READ, &i, FALSE); 
		// WH_DEBUG 1/23/15 added this read from 0x9C -- seems wrong to write a modified 0x80to 0x9C, those bits have different meanings!
		i |= (0x40000000); // assert bit 30 of 0x9C. bit self-clears
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_CFG, WDC_WRITE, &i, FALSE);
		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init): Requested recalibration");
		Pixie_Print_MSG(ErrMSG,1);
		Pixie_Sleep(1);
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SDRAM_STATUS, WDC_READ, &i, FALSE);
		sprintf(ErrMSG, "*INFO* (PIXIE500E_DMA_Init): SDRAM STATUS after recalibration: at register 0x80: 0x%X", i);
		Pixie_Print_MSG(ErrMSG,1);
		return 0xFFFF;
	}
	//sprintf(ErrMSG, "*DEBUG* (PIXIE500E_DMA_Init): DMA init done!");
	//Pixie_Print_MSG(ErrMSG,1);
	return 0;
}


// vdma.c functionality (VDMA sequencer instructions)

// Run VDMA from current DPTR position
void VDMADriver_Go(WDC_DEVICE_HANDLE hDev)
{
	UINT32 cmd = 1;
	UINT32 val=0;
	UINT32 timeout=0;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	do  {
		dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_CSRx, WDC_WRITE, &cmd, FALSE);
		dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_CSRx, WDC_READ, &val, FALSE);
		timeout++;
		//sprintf(ErrMSG, "*DEBUG* (VDMADriver_Go): CSR=0x%08X", val);
		//Pixie_Print_MSG(ErrMSG,1);
	} while ( (timeout<10) & (val != cmd)) ; 
	if(timeout>=10) {
		sprintf(ErrMSG, "*ERROR* (VDMADriver_Go): Starting DMA failed");
		Pixie_Print_MSG(ErrMSG,1);
	}
}

// Halt VDMA 
void VDMADriver_Halt(WDC_DEVICE_HANDLE hDev)
{
	UINT32 cmd = 2;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	//dwStatus=WriteMemoryAddrSpace(BAR0, VDMA_CSRx, &cmd, REG_32);
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_CSRx, WDC_WRITE, &cmd, FALSE);
}



// VDMA idle ? 
BOOL VDMADriver_isIdle(WDC_DEVICE_HANDLE hDev)
{
	UINT32 val= 0;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;

	
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_CSRx, WDC_READ, &val, FALSE);

	if(val & 0x1) {
		//sprintf(ErrMSG, "*DEBUG* VDMADriver_isIdle(): NOT IDLE");
		//Pixie_Print_MSG(ErrMSG,1);
		return FALSE;
	}
	//sprintf(ErrMSG, "*DEBUG* VDMADriver_isIdle(): IDLE");
	//Pixie_Print_MSG(ErrMSG,1);
	return TRUE;

}

// Set DPTRx value 
void VDMADriver_SetDPTR(WDC_DEVICE_HANDLE hDev, UINT32 val)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	// Access to DPTRx is allowed only when sequncer is idle 
	if(VDMADriver_isIdle(hDev))
	{
		dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_DPTRx, WDC_WRITE, &val, FALSE);
	}
}

// Get DPTRx value 
UINT32 VDMADriver_GetDPTR(WDC_DEVICE_HANDLE hDev)
{
	UINT32 val = 0;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	// Access to DPTRx is allowed only when sequncer is idle 
	if(VDMADriver_isIdle(hDev))
	{
		dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_DPTRx, WDC_READ, &val, FALSE);
	}

	return val;
}

// Event Set 
void VDMADriver_EventSet(WDC_DEVICE_HANDLE hDev, UINT32 val)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_EVENT_SETx, WDC_WRITE, &val, FALSE);
}

// Event Clear 
void VDMADriver_EventClear(WDC_DEVICE_HANDLE hDev, UINT32 val)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_EVENT_CLRx, WDC_WRITE, &val, FALSE);
}

// Event Enable 
void VDMADriver_SetEventEnable(WDC_DEVICE_HANDLE hDev, UINT32 val)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_EVENT_ENx, WDC_WRITE, &val, FALSE);
}

// Event Enable get 
UINT32 VDMADriver_GetEventEnable(WDC_DEVICE_HANDLE hDev)
{
	UINT32 value = 0;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_EVENT_ENx, WDC_READ, &value, FALSE);

	return value;
}

// Return Event status 
UINT32 VDMADriver_GetEventStatus(WDC_DEVICE_HANDLE hDev)
{
	UINT32 value = 0;
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, VDMA_EVENTx, WDC_READ, &value, FALSE);

	return value;
}

// Register bit definition 
// KS. A bit updated from Gennum implementation, following the Flex DMA design guide.
typedef union
{
	struct
	{
		unsigned CNT		: 12;// transfer count, bytes
		unsigned XFER_EN	: 1;// bit 12 reserved
		unsigned DIRECTION	: 1;// 0 L2P, 1 P2L
		unsigned UNUSED		: 2;// bits 14:15 reserved
		unsigned STREAM_ID	: 8; // was 4. Bits 16:23 STR_ID
		unsigned UNUSED2	: 7;
		unsigned C			: 1;
	} bits;
	UINT32 value;
}XFER_CTL_REG;


// Create xfer control instruction based on input parameters 
UINT32 VDMADriver_CreateXferCtlInstruction(WDC_DEVICE_HANDLE hDev, UINT8 c, UINT8 streamID, UINT8 direction, UINT16 cnt)
{
	XFER_CTL_REG xferReg;
	xferReg.value = 0;

	xferReg.bits.C = c;
	if(streamID > 0x3)
		xferReg.bits.STREAM_ID = 0;
	else
		xferReg.bits.STREAM_ID = streamID;

	xferReg.bits.DIRECTION = direction;

	// Only allow maximum of 4K per DMA transfer
	if(cnt >= 4096)
		xferReg.bits.CNT = 0;
	else
		xferReg.bits.CNT = cnt;

	return xferReg.value;
}








 //Setup GN registers for INT3 external interrupt.
 //Connect with the ISR.
 //This will be called from Pixie_Acquire_Data(0x1000)
void PIXIE500E_InterruptSetup_INT3(WDC_DEVICE_HANDLE hDev, U8 ModNum, U16 RunType)
{
	DWORD dwStatus, i;
	PPIXIE500E_DEV_CTX pDevCtx;	
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	// Prepare for interrupt processing
	// Clear INT_CFG0 (used for INT3)
	i = 0x0;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_CFG0, WDC_WRITE, &i, FALSE);

	// For interrupt type GPIO_BYPASS_INT_EDGE

	// All for only one INT0
	// Disable generation of GPIO_INT in INT_STAT to prevent interrupt detection by the GPIO block.
	// (masked by GPIO_INT_MASK, GPIO_INT is disabled)
	i = 0xFFFF;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, GPIO_INT_MASK_SET, WDC_WRITE, &i, FALSE);

	// Rising edge trigger in INT3
	i = 0x8;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_CTRL, WDC_WRITE, &i, FALSE);

	// GPIO INT3
	i = 0x8;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, GPIO_BYPASS_MODE, WDC_WRITE, &i, FALSE);

	VDMADriver_EventClear(hDev, 0xFF);
	VDMADriver_GetEventStatus(hDev); 

	// Event 0x08 used for INT3 (tested to work with INT_CFG0)
	VDMADriver_SetEventEnable(hDev, 0x08); // enable VDMA_EVENT[7:0] to allow output on GPIO[7:0]

	// clear interrupts (not just read, but clear)
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_STAT, WDC_READ, &i, FALSE);
	i = 0xFFFFFFF3;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_STAT, WDC_WRITE, &i, FALSE);

	// Enable INT3 on CFG0
	i = 0x80; // Bit 7: INT3
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_CFG0, WDC_WRITE, &i, FALSE);

	// General interrupt setup and ISR init
	PIXIE500E_IntEnable(hDev, PIXIE500E_IntHandler_INT3);

	// Set module number and run type in device context struct
	pDevCtx->dModNum = ModNum;
	pDevCtx->dRunType = RunType;

	i = 0xFFFF;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, GPIO_INT_MASK_CLR, WDC_WRITE, &i, FALSE);
	VDMADriver_SetEventEnable(hDev, 0xFF);

	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_STAT, WDC_READ, &i, FALSE);
	sprintf(ErrMSG, "*DEBUG* (PIXIE500E_InterruptSetup_INT3): ready to assert INT_STAT=0x%08X", i);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_other);
}

static void PIXIE500E_IntHandler_INT3(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_RESULT *pIntResult)
{
	DWORD dwStatus, i;
	PPIXIE500E_DEV_CTX pDevCtx;	
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	pDevCtx = (PPIXIE500E_DEV_CTX)WDC_GetDevContext(pDev);

	// Setup for the next interrupt: enable event 0x8 (all events were disabled in kernel ISR)
	// and clear INT_STAT
	VDMADriver_EventClear(hDev, 0x08);
	VDMADriver_SetEventEnable(hDev, 0x08);
	i = 0xFFFFFFF3;
	dwStatus = PIXIE500E_ReadWriteReg(hDev, INT_STAT, WDC_WRITE, &i, FALSE);

	// Then do the work: buffer QC, file dump, DMA restart
	sprintf(ErrMSG, "*DEBUG* (PIXIE500E_IntHandler_INT3): calling Write_DMA_List_Mode_File for Module %d", pDevCtx->dModNum);
	Pixie_Print_MSG(ErrMSG,PrintDebugMsg_other);
	dwStatus = Write_DMA_List_Mode_File ((U8)(pDevCtx->dModNum), "", (U16)(pDevCtx->dRunType));
}




// Structure of the boot section header as described in 
// Engineer-to-engineer note EE-56 from Analog Devices, 
// Tips and Tricks on SHARC EPROM and Host Boot Loader, Rev.3, March 6, 2007
UINT32 PIXIE500E_ProgramDSP(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus = WD_WINDRIVER_STATUS_ERROR;
	FILE *fp = NULL;
	UINT32* buffer = malloc(P500E_DSP_CODE_BYTES);
	UINT32 dwCount;
	UINT32 i, j, headerIndex;
	UINT16 wLdrTag, wLdrCount, repcount;
	BOOL pauseAfterZero = FALSE;
	BOOL ldrok = FALSE;
	UINT32 dwData, dwDataTmp;
	UINT8 *bBuffer = P500e_DSP_Code;
	UINT8 ErrMSG[256];
	BOOL finalInit = FALSE;


	UINT32 dwLdrFileLengthBytes;//  in bytes
	// 16-bit data, 256 groups of 3
	// (48-b real data) are sent in. So, the Kernel Length in B is 256*3 DWORDS
	const UINT32 dwLdrKernelLengthBytes = 1536;// in DW (1536B = 4B*384=6B*256)

	if (!buffer) {
		sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramDSP): Error allocating buffer LDR");
		Pixie_Print_MSG(ErrMSG,1);
		return(-3);
	}

	dwLdrFileLengthBytes = P500E_DSP_CODE_BYTES;

	// Read in the LDR file, created with VisualDSP, SPI slave, Binary, 8-bit packing
	for (j = 0; j < dwLdrFileLengthBytes/WDC_SIZE_32; j++) {
		buffer[j] = 0x00000000;
		buffer[j] += (bBuffer[4*j + 0] << 0)  & 0x000000FF;
		buffer[j] += (bBuffer[4*j + 1] << 8)  & 0x0000FF00;
		buffer[j] += (bBuffer[4*j + 2] << 16) & 0x00FF0000;
		buffer[j] += (bBuffer[4*j + 3] << 24) & 0xFF000000;
	}

	repcount = 5;
	do {
		// Just make sure that the clocks are working OK and we didn't lose BAR4
		dwStatus = PIXIE500E_ReadWriteReg(hDev, CLK_CSR, WDC_READ, &dwData, FALSE);
		if ((dwData & 0xF0000000) != 0xE0000000) {
			sprintf(ErrMSG, "*ERROR*(PIXIE500E_ProgramDSP): Problem with PLL lock, CLK_CSR=0x%08X", dwData);
			Pixie_Print_MSG(ErrMSG,1);
			return(-4);
		}

		// Force DSP reset
		dwData = 0x0;
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_WRITE, &dwData, FALSE);
		Pixie_Sleep(5);

		// Read it just in case
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_READ, &dwData, FALSE);
		sprintf(ErrMSG, "*INFO*(PIXIE500E_ProgramDSP): APP_HOST_CTL = %x",dwData );
		Pixie_Print_MSG(ErrMSG,PrintDebugMsg_Boot);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash

		dwData = 0x10;
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_WRITE, &dwData, FALSE);
		// Read it just in case
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_HOST_CTL, WDC_READ, &dwData, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) )return REGIO_ERR;		// fatal error causing system crash


		// Clear the SPI word counter: writing anything clears it.
		dwData = 0x0;
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SPI_CTL, WDC_WRITE, &dwData, FALSE);
		// Read it just in case
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_STATUS, WDC_READ, &dwData, FALSE);
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash
		Pixie_Sleep(1);


		// The Kernel Header, the initial part of the LDR file (256 48-bit words)
		headerIndex = dwLdrKernelLengthBytes/WDC_SIZE_32;

		// send out the kernel, 256 of 48-bit words.
		i=0;
		while (i < headerIndex) {
			dwData = buffer[i];
			i++;
			dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SPI, WDC_WRITE, &dwData, FALSE);
			wait_for_a_short_time(30000);
		} // while boot kernel loop

		Pixie_Sleep(30);

		// check if kernel initialized ok: SPI flags 3,2 should be 0,1
		dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_STATUS, WDC_READ, &dwData, FALSE);	
		if( (dwStatus==WD_WINDRIVER_STATUS_ERROR) || (dwData==0xFFFFFFFF) ) return REGIO_ERR;		// fatal error causing system crash

		ldrok = ((dwData & 0x000C) == 0x0004);
		if(ldrok==0) {
			sprintf(ErrMSG, "*INFO* (PIXIE500E_ProgramDSP): CSR = %x", dwData);
			Pixie_Print_MSG(ErrMSG,1);
		}
		repcount = repcount -1;

	} while ((ldrok==0) && (repcount>0) );

	if(ldrok==0) 
	{
	  sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramDSP): Kernel not initialized.");
	  Pixie_Print_MSG(ErrMSG,1);
	  return(-3);
	}

	/**********************************************************************************/
	/* Here done with boot kernel */
	/**********************************************************************************/

	while (i < dwLdrFileLengthBytes/WDC_SIZE_32) {
		// Assume that data is:
		// 0x0000 0000 00TT (tag)
		// 0xAAAA AAAA LLLL (length, address)
		wLdrTag = (UINT16)(buffer[headerIndex] & 0x000000FF);
		wLdrCount = (UINT16)((buffer[headerIndex+1] & 0x0000FFFF));

		if (wLdrTag >= 0x0 && wLdrTag <= 0x1A){ // It is a known header
			// If the tag is Zero-command, send out  Tag, Count, Address, 
			// and pause for DSP to process it.
			// If the tag is Init-command, send out Tag, Count, Address,
			// and the data payload (amount given by "Count") that follows the header.
			switch (wLdrTag) {
			  case ZERO_LDATA:
			  case ZERO_L48:
			  case ZERO_EXT8:
			  case ZERO_EXT16:
				  pauseAfterZero = TRUE;
				  headerIndex+=3;
				  break;

			  case INIT_L16:
				  headerIndex+=3;
				  if (wLdrCount % 2 == 0) {
					  headerIndex+=(wLdrCount/2);
				  }
				  else {
					  headerIndex+=((wLdrCount+1)/2);
				  }
				  break;

			  case INIT_L32:
				  headerIndex+=3;
				  headerIndex+=wLdrCount;
				  break;

			  case INIT_L48:
				  headerIndex+=3;
				  if (wLdrCount % 2 == 0) {
					  headerIndex+= (int)((6./4) * (double)(wLdrCount));// pad with empty 48-bit word if count is odd.
				  }
				  else {
					  headerIndex+= (int)((6./4) * (double)(wLdrCount+1));
				  }
				  break;

			  case INIT_L64:
				  headerIndex+=3;
				  headerIndex+=(2*wLdrCount); // 64-bit words
				  break;

			  case FINAL_INIT:
				  headerIndex=dwLdrFileLengthBytes/WDC_SIZE_32;//+=(3+384); // 256 6B words=384 4B words
				  finalInit = TRUE;
				  break;

			  default:
				  //printf("Unidentified tag\n");
				  sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramDSP): Unidentified tag.");
				  Pixie_Print_MSG(ErrMSG,1);
				  break;

			} // switch Init header tag
		} //if tag
		else {
			sprintf(ErrMSG, "*ERROR* (PIXIE500E_ProgramDSP): Cannot parse the LDR file.");
			Pixie_Print_MSG(ErrMSG,1);
			return(-5);
		}

		while ( i<headerIndex) {
			dwData = buffer[i];
			dwStatus = PIXIE500E_ReadWriteReg(hDev, APP_SPI, WDC_WRITE, &dwData, FALSE);
			i++;
			wait_for_a_short_time(30000);

			if (pauseAfterZero) {
				pauseAfterZero = FALSE;
				Pixie_Sleep(1);
			}
		} // while until next header
	} // while all words in LDR ********************

	Pixie_Sleep(1);

	free(buffer);

	return(dwStatus);

}

