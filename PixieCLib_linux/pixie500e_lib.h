#ifndef _PIXIE500E_LIB_H_
#define _PIXIE500E_LIB_H_

/************************************************************************
*  File: PIXIE500E_lib.h
*
*  Library for accessing PIXIE500E devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v10.20.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
* 
* Modified by KS, spring-summer 2011. Most of the constants, the FPGA, EEPROM
* programming protocol, DMA setup, are adopted from the GenDialog code
* that was provided with the GN4124 RDK board.
* 
*************************************************************************/

/* Fixing problems with UINT8 and UINT16 under Linux */
//
#if !defined(UINT8)
	typedef unsigned char UINT8;
#endif
#if !defined(UINT16)
	typedef unsigned short UINT16;
#endif
#if !defined(UINT32)
	typedef unsigned int UINT32;
#endif

#if !defined(INT8)
	typedef int INT8;
#endif

#if !defined(INT16)
	typedef int INT16;
#endif

#if !defined(INT32)
	typedef int INT32;
#endif

#include "wdc_lib.h"
#include "wdc_defs.h"
// For WinDriver 11.2 (Windows) pci_regs.h and bits.h are in samples/shared
// For Linux (12.21) they are along with other headers
#ifdef XIA_WINDOZE
#include "samples/shared/pci_regs.h"
#include "samples/shared/bits.h"
#else
#include "pci_regs.h"
#include "bits.h"
#endif
#include "samples/shared/wdc_diag_lib.h" // needed for WDC_REG definition
#include "status_strings.h"
#include "utils.h"

#include "vdma_seqcode.h"

	// Needed for DMA bandwidth tests
#include <time.h>

#ifdef __cplusplus
extern "C" {
#endif

	/*************************************************************
	General definitions
	*************************************************************/
	/* Default vendor and device IDs */
#define PIXIE500E_DEFAULT_VENDOR_ID 0x1A39 /* Vendor ID */
#define PIXIE500E_DEFAULT_DEVICE_ID 0x4 /* Device ID */



	/* Address space information struct */
#define MAX_TYPE 8
	typedef struct {
		DWORD dwAddrSpace;
		CHAR sType[MAX_TYPE];
		CHAR sName[MAX_NAME];
		CHAR sDesc[MAX_DESC];
	} PIXIE500E_ADDR_SPACE_INFO;

	/* Interrupt result information struct */
	typedef struct
	{
		DWORD dwCounter; /* Number of interrupts received */
		DWORD dwLost;    /* Number of interrupts not yet handled */
		WD_INTERRUPT_WAIT_RESULT waitResult; /* See WD_INTERRUPT_WAIT_RESULT values in windrvr.h */
		DWORD dwEnabledIntType; /* Interrupt type that was actually enabled
								(MSI/MSI-X/Level Sensitive/Edge-Triggered) */
		DWORD dwLastMessage; /* Message data of the last received MSI/MSI-X
							 (Windows Vista/7); N/A to line-based interrupts) */
	} PIXIE500E_INT_RESULT;
	/* TODO: You can add fields to PIXIE500E_INT_RESULT to store any additional
	information that you wish to pass to your diagnostics interrupt
	handler routine (DiagIntHandler() in PIXIE500E_diag.c) */

	/* PIXIE500E diagnostics interrupt handler function type */
	typedef void (*PIXIE500E_INT_HANDLER)(WDC_DEVICE_HANDLE hDev,
		PIXIE500E_INT_RESULT *pIntResult);

	/* PIXIE500E diagnostics plug-and-play and power management events handler function type */
	typedef void (*PIXIE500E_EVENT_HANDLER)(WDC_DEVICE_HANDLE hDev,
		DWORD dwAction);

	//// PIXIE500E register definitions 
	//enum { PIXIE500E_INT_STAT_SPACE = AD_PCI_BAR4 };
	//enum { PIXIE500E_INT_STAT_OFFSET = 0x814 };

	/* -----------------------------------------------
	PIXIE500E run-time registers information
	----------------------------------------------- */
	/* Run-time registers information array */
	//const WDC_REG gPIXIE500E_Regs[] = {
	//    { PIXIE5000E_INT_STAT_SPACE, PIXIE5000E_INT_STAT_OFFSET, WDC_SIZE_32, WDC_READ_WRITE, "INT_STAT", "" },
	//    };

	// N.B. Don't forget to check register r/w status
	// When adding a register, don't forget to enter it in the appropriate place in the enum after this one!
	static const WDC_REG gPIXIE500E_Regs[] = {
		{AD_PCI_BAR0, 0x004, WDC_SIZE_32, WDC_READ_WRITE, "DMA_CFG", "" },
		{AD_PCI_BAR0, 0x008, WDC_SIZE_32, WDC_WRITE, "VDMA_EVENT_SETx", "" },
		{AD_PCI_BAR0, 0x00C, WDC_SIZE_32, WDC_WRITE, "VDMA_EVENT_CLRx", "" },
		{AD_PCI_BAR0, 0x010, WDC_SIZE_32, WDC_READ, "VDMA_EVENTx", "" },
		{AD_PCI_BAR0, 0x014, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_EVENT_ENx", "" },
		{AD_PCI_BAR0, 0x018, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_SYS_ADDR_LO", "" },
		{AD_PCI_BAR0, 0x01C, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_SYS_ADDR_HI", "" },
		{AD_PCI_BAR0, 0x020, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_DPTRx", "" },
		{AD_PCI_BAR0, 0x024, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_XFER_CTRL", "" },
		{AD_PCI_BAR0, 0x028, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_RA", "" },
		{AD_PCI_BAR0, 0x02C, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_RB", "" },
		{AD_PCI_BAR0, 0x030, WDC_SIZE_32, WDC_READ_WRITE, "VDMA_CSRx", "" },
		{AD_PCI_BAR0, 0x034, WDC_SIZE_32, WDC_READ_WRITE, "DMA_PAYLOAD_SIZE", "" },
		{AD_PCI_BAR0, 0x038, WDC_SIZE_32, WDC_READ_WRITE, "DMA_STATUS", "" },
		{AD_PCI_BAR0, 0x03C, WDC_SIZE_32, WDC_READ, "DMA_STATUS_RAW", "" },
		{AD_PCI_BAR0, 0x040, WDC_SIZE_32, WDC_WRITE, "APP_SPI", "" },
		{AD_PCI_BAR0, 0x048, WDC_SIZE_32, WDC_WRITE, "APP_SPI_CTL", "" },
		{AD_PCI_BAR0, 0x050, WDC_SIZE_32, WDC_READ, "APP_STATUS", "" },
		{AD_PCI_BAR0, 0x054, WDC_SIZE_32, WDC_READ, "APP_STATUS_DATA", "" },
		{AD_PCI_BAR0, 0x060, WDC_SIZE_32, WDC_READ, "APP_GEN_COUNT", "" },
		{AD_PCI_BAR0, 0x068, WDC_SIZE_32, WDC_READ, "APP_RCV_COUNT", "" },
		{AD_PCI_BAR0, 0x070, WDC_SIZE_32, WDC_READ, "APP_RCV_ERR_COUNT", "" },
		{AD_PCI_BAR0, 0x078, WDC_SIZE_32, WDC_READ_WRITE, "APP_INIT_RD_WR_ADDR_DIFF", "" },
		{AD_PCI_BAR0, 0x080, WDC_SIZE_32, WDC_READ_WRITE, "APP_SDRAM_STATUS", "" },
		{AD_PCI_BAR0, 0x084, WDC_SIZE_32, WDC_READ, "APP_STATUS_RAW", "" },
		{AD_PCI_BAR0, 0x090, WDC_SIZE_32, WDC_READ_WRITE, "APP_HOST_CTL", "" }, // making it 32 for debug
		{AD_PCI_BAR0, 0x094, WDC_SIZE_32, WDC_READ_WRITE, "APP_HOST_CTL_DATA", "" },
		{AD_PCI_BAR0, 0x098, WDC_SIZE_32, WDC_READ_WRITE, "APP_STATUS_MASK", "" },
		{AD_PCI_BAR0, 0x09C, WDC_SIZE_32, WDC_READ_WRITE, "APP_CFG", "" },
		{AD_PCI_BAR0, 0x0A0, WDC_SIZE_32, WDC_READ_WRITE, "PL_WR_BRG_RD_THRES", "" },
		{AD_PCI_BAR0, 0x0A4, WDC_SIZE_32, WDC_READ_WRITE, "PL_WR_BRG_WR_THRES", "" },
		{AD_PCI_BAR0, 0x0A8, WDC_SIZE_32, WDC_READ_WRITE, "CAP_WR_BRG_WR_THRES", "" },
		{AD_PCI_BAR0, 0x0AC, WDC_SIZE_32, WDC_READ_WRITE, "CAP_WR_BRG_RD_THRES", "" },
		{AD_PCI_BAR0, 0x0B0, WDC_SIZE_32, WDC_READ_WRITE, "CAP_RD_BRG_WR_THRES", "" },
		{AD_PCI_BAR0, 0x0B4, WDC_SIZE_32, WDC_READ_WRITE, "CAP_RD_BRG_RD_THRES", "" },
		{AD_PCI_BAR4, 0x010, WDC_SIZE_32, WDC_READ, "PCIE_BAR0_LOW", ""},
		{AD_PCI_BAR4, 0x060, WDC_SIZE_16, WDC_READ_WRITE, "PCIE_DCR", ""},
		{AD_PCI_BAR4, 0x104, WDC_SIZE_32, WDC_READ_WRITE, "DSN_LOW", "" },
		{AD_PCI_BAR4, 0x108, WDC_SIZE_32, WDC_READ_WRITE, "DSN_HIGH", "" },
		{AD_PCI_BAR4, 0x800, WDC_SIZE_32, WDC_READ_WRITE, "PCI_SYS_CFG_SYSTEM", "" },
		{AD_PCI_BAR4, 0x804, WDC_SIZE_32, WDC_READ_WRITE, "LB_CTL", "" },
		{AD_PCI_BAR4, 0x808, WDC_SIZE_32, WDC_READ_WRITE, "CLK_CSR", "" },
		{AD_PCI_BAR4, 0x80C, WDC_SIZE_32, WDC_READ_WRITE, "PCI_BAR_CONFIG", "" },
		{AD_PCI_BAR4, 0x810, WDC_SIZE_32, WDC_READ_WRITE, "INT_CTRL", "" },
		{AD_PCI_BAR4, 0x814, WDC_SIZE_32, WDC_READ_WRITE, "INT_STAT", "" },
		{AD_PCI_BAR4, 0x818, WDC_SIZE_32, WDC_READ_WRITE, "PEX_ERROR_STAT", "" },
		{AD_PCI_BAR4, 0x820, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG0", "" },
		{AD_PCI_BAR4, 0x824, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG1", "" },
		{AD_PCI_BAR4, 0x828, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG2", "" },
		{AD_PCI_BAR4, 0x82C, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG3", "" },
		{AD_PCI_BAR4, 0x830, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG4", "" },
		{AD_PCI_BAR4, 0x834, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG5", "" },
		{AD_PCI_BAR4, 0x838, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG6", "" },
		{AD_PCI_BAR4, 0x83C, WDC_SIZE_32, WDC_READ_WRITE, "INT_CFG7", "" },
		{AD_PCI_BAR4, 0x840, WDC_SIZE_32, WDC_READ_WRITE, "PCI_TO_ACK_TIME", "" },
		{AD_PCI_BAR4, 0x844, WDC_SIZE_32, WDC_READ_WRITE, "PEX_CDN_CFG1", "" },
		{AD_PCI_BAR4, 0x848, WDC_SIZE_32, WDC_READ_WRITE, "PEX_CDN_CFG2", "" },
		{AD_PCI_BAR4, 0x84C, WDC_SIZE_32, WDC_READ_WRITE, "PHY_TEST_CONTROL", "" },
		{AD_PCI_BAR4, 0x850, WDC_SIZE_32, WDC_READ_WRITE, "PHY_CONTROL", "" },
		{AD_PCI_BAR4, 0x854, WDC_SIZE_32, WDC_READ_WRITE, "CDN_LOCK", "" },
		{AD_PCI_BAR4, 0x900, WDC_SIZE_16, WDC_READ_WRITE, "TWI_CTRL", "" },
		{AD_PCI_BAR4, 0x904, WDC_SIZE_16, WDC_READ_WRITE, "TWI_STATUS", "" },
		{AD_PCI_BAR4, 0x908, WDC_SIZE_16, WDC_READ_WRITE, "TWI_ADDRESS", "" },
		{AD_PCI_BAR4, 0x90C, WDC_SIZE_16, WDC_READ_WRITE, "TWI_DATA", "" },
		{AD_PCI_BAR4, 0x910, WDC_SIZE_16, WDC_READ_WRITE, "TWI_IRT_STATUS", "" },
		{AD_PCI_BAR4, 0x914, WDC_SIZE_8, WDC_READ_WRITE, "TWI_TR_SIZE", "" },
		{AD_PCI_BAR4, 0x918, WDC_SIZE_8, WDC_READ_WRITE, "TWI_SLV_MON", "" },
		{AD_PCI_BAR4, 0x91C, WDC_SIZE_16, WDC_READ_WRITE, "TWI_TO", "" },
		{AD_PCI_BAR4, 0x920, WDC_SIZE_16, WDC_READ_WRITE, "TWI_IR_MASK", "" },
		{AD_PCI_BAR4, 0x924, WDC_SIZE_16, WDC_READ_WRITE, "TWI_IR_EN", "" },
		{AD_PCI_BAR4, 0x928, WDC_SIZE_16, WDC_READ_WRITE, "TWI_IR_DIS", "" },
		{AD_PCI_BAR4, 0xA00, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_BYPASS_MODE", "" },
		{AD_PCI_BAR4, 0xA04, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_DIRECTION_MODE", "" },
		{AD_PCI_BAR4, 0xA08, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_OUTPUT_ENABLE", "" },
		{AD_PCI_BAR4, 0xA0C, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_OUTPUT_VALUE", "" },
		{AD_PCI_BAR4, 0xA10, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INPUT_VALUE", "" },
		{AD_PCI_BAR4, 0xA14, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_MASK", "" },
		{AD_PCI_BAR4, 0xA18, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_MASK_CLR", "" },
		{AD_PCI_BAR4, 0xA1C, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_MASK_SET", "" },
		{AD_PCI_BAR4, 0xA20, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_STATUS", "" },
		{AD_PCI_BAR4, 0xA24, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_TYPE", "" },
		{AD_PCI_BAR4, 0xA28, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_VALUE", "" },
		{AD_PCI_BAR4, 0xA2C, WDC_SIZE_32, WDC_READ_WRITE, "GPIO_INT_ON_ANY", "" },
		{AD_PCI_BAR4, 0xB00, WDC_SIZE_16, WDC_READ_WRITE, "FCL_CTRL", "" },
		{AD_PCI_BAR4, 0xB04, WDC_SIZE_16, WDC_READ_WRITE, "FCL_STATUS", "" },
		{AD_PCI_BAR4, 0xB08, WDC_SIZE_16, WDC_READ_WRITE, "FCL_IODATA_IN", "" },
		{AD_PCI_BAR4, 0xB0C, WDC_SIZE_16, WDC_READ_WRITE, "FCL_IODATA_OUT", "" },
		{AD_PCI_BAR4, 0xB10, WDC_SIZE_16, WDC_READ_WRITE, "FCL_EN", "" },
		{AD_PCI_BAR4, 0xB14, WDC_SIZE_16, WDC_READ_WRITE, "FCL_TIMER_0", "" },
		{AD_PCI_BAR4, 0xB18, WDC_SIZE_16, WDC_READ_WRITE, "FCL_TIMER_1", "" },
		{AD_PCI_BAR4, 0xB1C, WDC_SIZE_16, WDC_READ_WRITE, "FCL_CLK_DIV", "" },
		{AD_PCI_BAR4, 0xB20, WDC_SIZE_16, WDC_READ_WRITE, "FCL_IRQ", "" },
		{AD_PCI_BAR4, 0xB24, WDC_SIZE_16, WDC_READ_WRITE, "FCL_TIMER_CTRL", "" },
		{AD_PCI_BAR4, 0xB28, WDC_SIZE_16, WDC_READ_WRITE, "FCL_IM", "" },
		{AD_PCI_BAR4, 0xB2C, WDC_SIZE_16, WDC_READ_WRITE, "FCL_TIMER2_0", "" },
		{AD_PCI_BAR4, 0xB30, WDC_SIZE_16, WDC_READ_WRITE, "FCL_TIMER2_1", "" },
		{AD_PCI_BAR4, 0xB34, WDC_SIZE_16, WDC_READ_WRITE, "FCL_DBG_STS", "" },
		{AD_PCI_BAR4, 0xE00, WDC_SIZE_32, WDC_READ_WRITE, "FCL_FIFO_DATA", "" },
		{AD_PCI_BAR2, PCIE_EMDATA, WDC_SIZE_32, WDC_READ_WRITE, "EMDATA", ""}
	};

// This enum corresponds by register names to the array of registers above.
	enum {
		DMA_CFG ,
		VDMA_EVENT_SETx ,
		VDMA_EVENT_CLRx ,
		VDMA_EVENTx ,
		VDMA_EVENT_ENx ,
		VDMA_SYS_ADDR_LO ,
		VDMA_SYS_ADDR_HI ,
		VDMA_DPTRx ,
		VDMA_XFER_CTRL ,
		VDMA_RA ,
		VDMA_RB ,
		VDMA_CSRx ,
		DMA_PAYLOAD_SIZE ,
		DMA_STATUS ,
		DMA_STATUS_RAW ,
		APP_SPI ,
		APP_SPI_CTL ,
		APP_STATUS ,
		APP_STATUS_DATA ,
		APP_GEN_COUNT ,
		APP_RCV_COUNT ,
		APP_RCV_ERR_COUNT ,
		APP_INIT_RD_WR_ADDR_DIFF ,
		APP_SDRAM_STATUS ,
		APP_STATUS_RAW ,
		APP_HOST_CTL ,
		APP_HOST_CTL_DATA ,
		APP_STATUS_MASK ,
		APP_CFG ,
		PL_WR_BRG_RD_THRES ,
		PL_WR_BRG_WR_THRES ,
		CAP_WR_BRG_WR_THRES ,
		CAP_WR_BRG_RD_THRES ,
		CAP_RD_BRG_WR_THRES ,
		CAP_RD_BRG_RD_THRES ,
		PCIE_BAR0_LOW ,
		PCIE_DCR ,
		DSN_LOW ,
		DSN_HIGH ,
		PCI_SYS_CFG_SYSTEM ,
		LB_CTL ,
		CLK_CSR ,
		PCI_BAR_CONFIG ,
		INT_CTRL ,
		INT_STAT ,
		PEX_ERROR_STAT ,
		INT_CFG0 ,
		INT_CFG1 ,
		INT_CFG2 ,
		INT_CFG3 ,
		INT_CFG4 ,
		INT_CFG5 ,
		INT_CFG6 ,
		INT_CFG7 ,
		PCI_TO_ACK_TIME ,
		PEX_CDN_CFG1 ,
		PEX_CDN_CFG2 ,
		PHY_TEST_CONTROL ,
		PHY_CONTROL ,
		CDN_LOCK ,
		TWI_CTRL ,
		TWI_STATUS ,
		TWI_ADDRESS ,
		TWI_DATA ,
		TWI_IRT_STATUS ,
		TWI_TR_SIZE ,
		TWI_SLV_MON ,
		TWI_TO ,
		TWI_IR_MASK ,
		TWI_IR_EN ,
		TWI_IR_DIS ,
		GPIO_BYPASS_MODE ,
		GPIO_DIRECTION_MODE ,
		GPIO_OUTPUT_ENABLE ,
		GPIO_OUTPUT_VALUE ,
		GPIO_INPUT_VALUE ,
		GPIO_INT_MASK ,
		GPIO_INT_MASK_CLR ,
		GPIO_INT_MASK_SET ,
		GPIO_INT_STATUS ,
		GPIO_INT_TYPE ,
		GPIO_INT_VALUE ,
		GPIO_INT_ON_ANY ,
		FCL_CTRL ,
		FCL_STATUS ,
		FCL_IODATA_IN ,
		FCL_IODATA_OUT ,
		FCL_EN ,
		FCL_TIMER_0 ,
		FCL_TIMER_1 ,
		FCL_CLK_DIV ,
		FCL_IRQ ,
		FCL_TIMER_CTRL ,
		FCL_IM ,
		FCL_TIMER2_0 ,
		FCL_TIMER2_1 ,
		FCL_DBG_STS ,
		FCL_FIFO_DATA,
		EMDATA
	};

/********************* DMA-related definitions ***************************/

  // DMA sequencer code constants
  static const UINT32 m_RAMBase = 0x4000;	// Descriptor RAM base
  static const UINT32 m_RAMSize = 0x2000;   // Descriptor RAM size
  // Number of DWORD for 1 SG entry 
	static const UINT16 SG_ENTRY_SIZE      = 3;

  // Variable and constant location defintion
  static const UINT16 CONST_0       = 0;
  static const UINT16 CONST_NEG_1     = 1;
  static const UINT16 CONST_SG_LIST_SIZE  = 2;
  static const UINT16 PDM_SG_LIST_PTR   = 3;
  static const UINT16 PDM_SG_CNT      = 4;
  static const UINT16 LDM_SG_LIST_PTR   = 5;
  static const UINT16 LDM_SG_CNT      = 6;

  // Start location of the main program, after the constants above
  static const UINT16 MAIN_START      = 7;
  // Start of data section. This is where address/xfer_ctl are starting.
  // NOTE:  This value is based on manual instruction counting: adjust if the sequencer code is really big. 
  static const UINT16 DATA_SECTION_START = 40;
/*********** END of DMA definitions *********************/

/************* EEPROM section ********************************/
	// From eeprom.c of pci_low project
	/*  EEPROM entry macro */
#define EEPROM_ENTRY(reg, value) \
	(reg & 0xFF), ((reg >> 8) & 0xFF), (value & 0xFF), ((value >> 8) & 0xFF), \
	((value >> 16) & 0xFF), ((value >> 24) & 0xFF)

#define EEPROM_ENTRY_END        0xFF, 0xFF

#define MAX_RETRY               (2000000)
#define I2C_FIFO_SIZE   (8)
#define PAGE_SIZE       (8) // Length of page write operation
#define I2C_BAUD_RATE           (100000)  //100KHz default I2C baud rate

#define EEPROM_SIZE             (256) //Size of EEPROM in bytes
#define SLAVE_ADDR              (0x56) //Slave address of EEPROM
#define WRITE_DELAY             (10) //In milliseconds
#define EEPROM_WD_SIZE			6		// number of bytes used per "word"

	static unsigned char GN4124_EEPROM_DEFAULT[EEPROM_SIZE] =
	{
//	    EEPROM_ENTRY(0xF808, 0x0809F03C),       //200MHz FOUT with 25Mhz oscillator, PLL and DLL reset
//	    EEPROM_ENTRY(0xF808, 0x0001F03C),       //200MHz FOUT with 25Mhz oscillator     
//	    EEPROM_ENTRY(0xF808, 0x080A504C),       //190MHz FOUT with 25Mhz oscillator, PLL and DLL reset
//	    EEPROM_ENTRY(0xF808, 0x0002504C),       //190MHz FOUT with 25Mhzls oscillator	      
//	    EEPROM_ENTRY(0xF808, 0x080A204C),       //175MHz FOUT with 25Mhz oscillator, PLL and DLL reset
//	    EEPROM_ENTRY(0xF808, 0x0002204C),       //175MHz FOUT with 25Mhz oscillator
		// 160 MHz is stable for RevB
	    EEPROM_ENTRY(0xF808, 0x0809F04C),       //160MHz FOUT with 25Mhz oscillator, PLL and DLL reset
	    EEPROM_ENTRY(0xF808, 0x0001F04C),       //160MHz FOUT with 25Mhz oscillator
		// 125 MHz, test, whether it helps with BAR0
//	    EEPROM_ENTRY(0xF808, 0x0809804C),       //125MHz FOUT with 25Mhz oscillator, PLL and DLL reset
//	    EEPROM_ENTRY(0xF808, 0x0001804C),       //125MHz FOUT with 25Mhz oscillator

		EEPROM_ENTRY(0xF05C, 0x00008002),		//PCIe. Device Capabilities register
		EEPROM_ENTRY(0xF060, 0x00005840),		//PCIe Device Control register
		EEPROM_ENTRY(0xF850, 0x00000028),		//RASER CONTROL setting
/*
		EEPROM_ENTRY(0xE008, 0x00000000),		//Set PCI_CLASS_CODE.  Base class = 0x00, sub-class = 0x00, interface = 0x00
		here we write the default. see if it can be replaced by write of sub_sys/sub_vendor
*/
		EEPROM_ENTRY(0xF02C, 0xA5511C40),		// PCI_SUB_SYSTEM (XIA device ID) | PCI_SUB_VENDOR (XIA=0x1C40). 
												// Device ID default is changed in Pixie500e_program_EEPROM.exe
		EEPROM_ENTRY(0xF800, 0x00065000),		// PCI_SYS_CONFIG_SYSTEM (disable VC, enable SN, MSI) 
												// writing PCI_SYS_CONFIG_SYSTEM ends programming GN chip 				
		EEPROM_ENTRY(0xF104, 0xBEEFA101),		// Device Serial Number Low bits, S/N (upper 16), revision (lower 16): Rev A = 0xA100, Rev B = 0xA101
												// since written after PCI_SYS_CONFIG_SYSTEM, it's not applied to GN register. Read during boot process from EEPROM.
												// revision default is changed in Pixie500e_program_EEPROM.exe
		EEPROM_ENTRY_END						// End token
	};

	static const UINT32 PCICLK = 125000000; //Internal PCLK frequency
/****************** END of EEPROM section ***************************/


/************* DSP LDR tags *********************/
// definitions of DSP tags in LDR, according to VisualDSP  Loader manual
#define FINAL_INIT 0x0
#define ZERO_LDATA 0x1
#define ZERO_L48 0x2
#define	INIT_L16 0x3
#define INIT_L32 0x4
#define INIT_L48 0x5
#define INIT_L64 0x6
#define ZERO_EXT8 0x7
#define ZERO_EXT16 0x8
#define INIT_EXT8 0x9
#define INIT_EXT16 0xA
#define MULT_PROC 0xB
/************* END of DSP section *********************/





	/* PIXIE500E device information struct */
	typedef struct {
		WD_TRANSFER      *pIntTransCmds;
		PIXIE500E_INT_HANDLER   funcDiagIntHandler;
		PIXIE500E_EVENT_HANDLER funcDiagEventHandler;
		unsigned short dModNum;
		unsigned int dRunType;
	} PIXIE500E_DEV_CTX, *PPIXIE500E_DEV_CTX;
	/* TODO: You can add fields to store additional device-specific information */



	/*************************************************************
	Function prototypes
	*************************************************************/
	DWORD PIXIE500E_LibInit(void);
	DWORD PIXIE500E_LibUninit(void);

	WDC_DEVICE_HANDLE PIXIE500E_DeviceOpen(const WD_PCI_CARD_INFO *pDeviceInfo);
	BOOL PIXIE500E_DeviceClose(WDC_DEVICE_HANDLE hDev);

	static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item);
	DWORD PIXIE500E_IntEnable(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_HANDLER funcIntHandler);
	DWORD PIXIE500E_IntDisable(WDC_DEVICE_HANDLE hDev);
	BOOL PIXIE500E_IntIsEnabled(WDC_DEVICE_HANDLE hDev);

	DWORD PIXIE500E_EventRegister(WDC_DEVICE_HANDLE hDev, PIXIE500E_EVENT_HANDLER funcEventHandler);
	DWORD PIXIE500E_EventUnregister(WDC_DEVICE_HANDLE hDev);
	BOOL PIXIE500E_EventIsRegistered(WDC_DEVICE_HANDLE hDev);

	DWORD PIXIE500E_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev);
	BOOL PIXIE500E_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, PIXIE500E_ADDR_SPACE_INFO *pAddrSpaceInfo);

	// Function: PIXIE500E_ReadINT_STAT()
	//   Read from INT_STAT register.
	//UINT32 PIXIE500E_ReadINT_STAT (WDC_DEVICE_HANDLE hDev);

	// Function: PIXIE500E_WriteINT_STAT()
	//   Write to INT_STAT register.
	//void PIXIE500E_WriteINT_STAT (WDC_DEVICE_HANDLE hDev, UINT32 data);


	const char *PIXIE500E_GetLastErr(void);

	DWORD PIXIE500E_ReadWriteReg(WDC_DEVICE_HANDLE hDev, DWORD dwReg, WDC_DIRECTION direction, void * value, BOOL fPciCfg);

	// EEPROM IO
	UINT32 PIXIE500E_ReadI2C(WDC_DEVICE_HANDLE hDev, void *buffer, UINT32 devAddr, UINT32 offset, UINT32 len);
	UINT32 PIXIE500E_WriteI2C(WDC_DEVICE_HANDLE hDev, const void *buffer, UINT32 addr, UINT32 offset, UINT32 len);
	UINT32 PIXIE500E_DumpI2CPROM(WDC_DEVICE_HANDLE hDev);
	UINT32 PIXIE500E_LoadDefaultI2CPROM(WDC_DEVICE_HANDLE hDev);
	UINT32 PIXIE500E_ReadI2C_Word(WDC_DEVICE_HANDLE hDev, U32 *eepromWord, UINT32 wordOffset);
	UINT32 PIXIE500E_WriteI2C_Word(WDC_DEVICE_HANDLE hDev, const UINT8 *eepromEntry, UINT32 wordOffset);

	// FPGA programming
	//UINT32 PIXIE500E_ProgramFPGA(WDC_DEVICE_HANDLE hDev, char const * filename, UINT32 fcl_clk_div);
	UINT32 PIXIE500E_ProgramFPGA(WDC_DEVICE_HANDLE hDev, UINT32 fcl_clk_div, UINT32 type);
	UINT32 PIXIE4E_ProgramFPGA(WDC_DEVICE_HANDLE hDev, UINT32 fcl_clk_div, UINT32 type);
	UINT32 PIXIE4E_FPGApostboot_IO(WDC_DEVICE_HANDLE hDev);
	void PIXIE500E_LBClkReset(WDC_DEVICE_HANDLE hDev);
	// DMA tests
	UINT32 PIXIE500E_DMA_Trace_Setup(WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize, DWORD *dwDMABuffer, WD_DMA **ppDmaL2P);
//	UINT32 PIXIE500E_DMA_SDRAM_Test(WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize, BOOL fPolling, BOOL fIsRead);
//	UINT32 PIXIE500E_DMA_SDRAM_Trace(WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize, DWORD *dwDMABuffer, BOOL fPolling, BOOL fIsRead);
//	void PIXIE500E_VDMACodeGen_P2L_L2P(WDC_DEVICE_HANDLE hDev, const void *pCodeBuffer, const WD_DMA *pDmaP2L, const WD_DMA *pDmaL2P);
//	void PIXIE500E_VDMACodeGen_TEST(WDC_DEVICE_HANDLE hDev, const void *pCodeBuffer, const WD_DMA *pDmaP2L, const WD_DMA *pDmaL2P);
	void PIXIE500E_VDMACodeGen_TraceOut(WDC_DEVICE_HANDLE hDev, const void *pCodeBuffer, const WD_DMA *pDmaL2P);
	UINT32 PIXIE500E_DMA_ProgramSequencer(WDC_DEVICE_HANDLE hDev, INT32 *m_CodeBuff);
	UINT32 PIXIE500E_DMA_Init(WDC_DEVICE_HANDLE hDev);
	DWORD PIXIE500E_DMA_WaitForCompletion(WDC_DEVICE_HANDLE hDev, BOOL fPolling);

	// vdma.h of GenDialog

	/* Start VDMA using current DPTRx value */
	DWORD VDMADriver_Go(WDC_DEVICE_HANDLE hDev);
	/* Single step sequencer instruction */
//	void VDMADriver_Step(WDC_DEVICE_HANDLE hDev);
	/* Halt VDMA */
	DWORD VDMADriver_Halt(WDC_DEVICE_HANDLE hDev);
	/* VDMA idle ? */
	BOOL VDMADriver_isIdle(WDC_DEVICE_HANDLE hDev);
	/* Set DPTRx value */
	void VDMADriver_SetDPTR(WDC_DEVICE_HANDLE hDev, UINT32 val);
	/* Get DPTRx value */
	UINT32 VDMADriver_GetDPTR(WDC_DEVICE_HANDLE hDev);
	/* Event Set */
	void VDMADriver_EventSet(WDC_DEVICE_HANDLE hDev, UINT32 val);
	/* Event Clear */
	void VDMADriver_EventClear(WDC_DEVICE_HANDLE hDev, UINT32 val);
	/* Event Enable set */
	void VDMADriver_SetEventEnable(WDC_DEVICE_HANDLE hDev, UINT32 val);
	/* Event Enable get */
	UINT32 VDMADriver_GetEventEnable(WDC_DEVICE_HANDLE hDev);
	/* Return Event status */
	UINT32 VDMADriver_GetEventStatus(WDC_DEVICE_HANDLE hDev);
	/* Create xfer control instruction based on input parameters */
	UINT32 VDMADriver_CreateXferCtlInstruction(WDC_DEVICE_HANDLE hDev, UINT8 c, UINT8 streamID, UINT8 direction, UINT16 cnt);

// SWI0 test
//	void TestIntHandler_SWI0(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_RESULT *pIntResult);
//	void PIXIE500E_InterruptTest_SWI0(WDC_DEVICE_HANDLE hDev);
// External INT3 test
//	void TestIntHandler_INT3(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_RESULT *pIntResult);
//	void PIXIE500E_InterruptTest_INT3(WDC_DEVICE_HANDLE hDev);
// External interrupt setup (INT3) for data acquisition
	void PIXIE500E_InterruptSetup_INT3(WDC_DEVICE_HANDLE hDev, U8 ModNum, U16 RunType);
	static void PIXIE500E_IntHandler_INT3(WDC_DEVICE_HANDLE hDev, PIXIE500E_INT_RESULT *pIntResult);
	// DSP programming
	UINT32 PIXIE500E_ProgramDSP(WDC_DEVICE_HANDLE hDev);


#ifdef __cplusplus
}
#endif

#endif
